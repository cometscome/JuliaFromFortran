<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FortranのコードをJuliaへ移植してみる · Fortranから始めるJulia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Fortranから始めるJulia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Fortranから始めるJulia</a></li><li><a class="tocitem" href="../../chapter1/01/">FortranとJuliaの文法比較</a></li><li><a class="tocitem" href="../../chapter1/02/">線形代数計算</a></li><li class="is-active"><a class="tocitem" href>FortranのコードをJuliaへ移植してみる</a><ul class="internal"><li><a class="tocitem" href="#マンデルブロ集合"><span>マンデルブロ集合</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>FortranのコードをJuliaへ移植してみる</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FortranのコードをJuliaへ移植してみる</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cometscome/JuliaFromFortran/blob/master/docs/src/chapter2/01.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FortranのコードをJuliaへ移植してみる"><a class="docs-heading-anchor" href="#FortranのコードをJuliaへ移植してみる">FortranのコードをJuliaへ移植してみる</a><a id="FortranのコードをJuliaへ移植してみる-1"></a><a class="docs-heading-anchor-permalink" href="#FortranのコードをJuliaへ移植してみる" title="Permalink"></a></h1><h2 id="マンデルブロ集合"><a class="docs-heading-anchor" href="#マンデルブロ集合">マンデルブロ集合</a><a id="マンデルブロ集合-1"></a><a class="docs-heading-anchor-permalink" href="#マンデルブロ集合" title="Permalink"></a></h2><p>こちらの<a href="https://qiita.com/cure_honey/items/795bd0e048ffeadc3e63">記事</a>にはさまざまなFortranのバージョンで書かれたマンデルブロ集合のコードが紹介されています。</p><h3 id="Fortran90"><a class="docs-heading-anchor" href="#Fortran90">Fortran90</a><a id="Fortran90-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran90" title="Permalink"></a></h3><p>この記事の中のFortran90のコードを引用します。コードは</p><pre><code class="language-fortran hljs">PROGRAM mandel
    IMPLICIT NONE
    INTEGER, PARAMETER :: nx = 61, ny = 31, maxiter = 90
    REAL   , PARAMETER :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    INTEGER :: ix, iy, iter, mandelbrot(nx, ny)
    REAL :: x, y
    COMPLEX :: z, c
    DO iy = 1, ny
      y = y0 + (y1 - y0) * (iy - 1) / REAL(ny - 1) 
      DO ix = 1, nx
        x = x0 + (x1 - x0) * (ix - 1) / REAL(nx - 1)  
        c = CMPLX(x, y)
        z = (0.0, 0.0)
        DO iter = 0, maxiter
          z = z * z + c
          IF (ABS(z) &gt; 2.0) EXIT
        END DO    
        mandelbrot(ix, iy) = iter
      END DO    
    END DO
!
    DO iy = 1, ny     
      PRINT &#39;(61I1)&#39;, (mandelbrot(:, iy) + 9) / 10 
    END DO          
    STOP
END PROGRAM mandel</code></pre><p>です。このコードをgfortranでコンパイルし、実行しますと、</p><pre><code class="nohighlight hljs">0000000000000000000000000000001000000000000000000000000000000
0000000000000000000011111111111111111111100000000000000000000
0000000000000000111111111111111111111111111110000000000000000
0000000000001111111111111111111111111111111111111000000000000
0000000000111111111111111111111111111111111111111110000000000
0000000011111111111111111111111111111111111111111111100000000
0000001111111111111111111111111111111111111111111111111000000
0000011111111111111111111111111111111111111111111111111100000
0000111111111111111111111111211111111111111111111111111110000
000111111111111111111111111***2111111111111111111111111111000
0011111111111111111113312223*72671111111111111111111111111100
0011111111111111111111*************61111111111111111111111100
011111111111111111112***************1111111111111111111111110
0111111111112*4*3412****************2111111111111111111111110
011111111212************************5111111111111111111111110
**********************************311111111111111111111111111
011111111212************************5111111111111111111111110
0111111111112*4*3412****************2111111111111111111111110
011111111111111111112***************1111111111111111111111110
0011111111111111111111*************61111111111111111111111100
0011111111111111111113312223*72661111111111111111111111111100
000111111111111111111111111***2111111111111111111111111111000
0000111111111111111111111111211111111111111111111111111110000
0000011111111111111111111111111111111111111111111111111100000
0000001111111111111111111111111111111111111111111111111000000
0000000011111111111111111111111111111111111111111111100000000
0000000000111111111111111111111111111111111111111110000000000
0000000000001111111111111111111111111111111111111000000000000
0000000000000000111111111111111111111111111110000000000000000
0000000000000000000011111111111111111111100000000000000000000
0000000000000000000000000000001000000000000000000000000000000</code></pre><p>という出力が得られます。この出力を再現するようなJuliaのコードを書いてみましょう。</p><p>作ったJuliaのコードは</p><pre><code class="language-julia hljs">function mandel()
    nx = 61; ny = 31; maxiter = 90
    x0 = -2.0; x1 = 2.0; y0 = -2.0; y1 = 2.0
    mandelbrot = zeros(Int64,nx, ny)
    mandelbrot .= maxiter
    for iy=1:ny
        y = y0 + (y1 - y0) * (iy - 1) / real(ny - 1) 
        for ix=1:nx
            x = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)
            c = x + im*y
            z = 0im
            for iter=0:maxiter
                z = z * z + c
                if abs(z) &gt; 2
                    mandelbrot[ix,iy] = iter
                    break
                end
            end
            
        end
    end
    for iy=1:ny
        for ix=1:nx
            if mandelbrot[ix,iy] == maxiter
                print(&quot;*&quot;)
            else
                print((mandelbrot[ix,iy]+9) ÷ 10)
            end
        end
        println(&quot;\t&quot;)
    end
end
mandel()</code></pre><p>です。</p><p>ポイントは</p><ol><li><code>program mandel</code>を<code>function mandel()</code>に変更</li><li><code>;</code>を使い一行に複数の文を入れた</li><li>配列<code>mandelbrot</code>を<code>mandelbrot = zeros(Int64,nx, ny)</code>で定義</li><li>Fortranでループを抜けるexitは、対応するbreakに変更</li><li>Fortranは<code>do iter = 0, maxiter</code>のループの途中で抜けた場合<code>iter</code>には抜けた時の値が入っているが、Juliaでは<code>iter</code>のスコープがローカルなので外では未定義になっている。そのため、<code>mandelbrot[ix,iy] = iter</code>とした</li><li><code>iter</code>のループが最大まで到達した時に、Fortranでは<code>mandelbrot(ix, iy)</code>の中身はループの最後の値<code>maxiter</code>になるが、Juliaでは前述のように<code>iter</code>はローカルスコープの変数なので値が入らない。なので、最初に<code>mandelbrot .= maxiter</code>と初期化した</li></ol><p>などです。見比べるとはっきりとわかりますが、Fortran90のコードとJuliaのコードはよく似ています。</p><h3 id="Fortran90-モジュールを使用"><a class="docs-heading-anchor" href="#Fortran90-モジュールを使用">Fortran90 モジュールを使用</a><a id="Fortran90-モジュールを使用-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran90-モジュールを使用" title="Permalink"></a></h3><p>次は、モジュールを使用したコードをJuliaコードに変化させてみます。 コードはこちらの<a href="https://qiita.com/cure_honey/items/795bd0e048ffeadc3e63">記事</a>からの引用しまして、</p><pre><code class="language-fortran hljs">MODULE m_mandel
    IMPLICIT NONE
    INTEGER, PARAMETER :: maxiter = 90
  CONTAINS
    INTEGER FUNCTION mandel(c)
      COMPLEX, INTENT(IN) :: c
      COMPLEX :: z
      z = (0.0, 0.0)
      DO mandel = 0, maxiter
        z = z * z + c
        IF (ABS(z) &gt; 2.0) EXIT
      END DO    
    END FUNCTION mandel 
  END MODULE m_mandel

  PROGRAM mandel_main
    USE m_mandel
    IMPLICIT NONE
    INTEGER, PARAMETER :: nx = 61, ny = 31
    REAL   , PARAMETER :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    INTEGER :: ix, iy, iter, mandelbrot(nx, ny)
    REAL :: x, y
    DO iy = 1, ny
      y = y0 + (y1 - y0) * (iy - 1) / REAL(ny - 1)   
      DO ix = 1, nx
        x = x0 + (x1 - x0) * (ix - 1) / REAL(nx - 1)  
        mandelbrot(ix, iy) = mandel(CMPLX(x, y)) 
      END DO    
    END DO
!
    DO iy = 1, ny
      PRINT &#39;(61i1)&#39;, (mandelbrot(:, iy) + 9) / 10  
    END DO    
    STOP
  END PROGRAM mandel_main</code></pre><p>というものです。</p><p>このコードをJuliaに移植してみますと、</p><pre><code class="language-julia hljs">module M_mandel
    const maxiter = 90
    export mandel,maxiter

    function mandel(c)
        z = 0im
        count = maxiter
        for i=0:maxiter
            z = z * z + c
            if abs(z) &gt; 2
                count = i
                break
            end
        end
        return count
    end
end

using .M_mandel
function mandel_main()
    nx = 61;ny = 31
    x0 = -2.0;x1 = 2.0;y0 = -2.0;y1 = 2.0
    mandelbrot = zeros(Int64,nx, ny)

    for iy=1:ny
        y = y0 + (y1 - y0) * (iy - 1) / real(ny - 1)
        for ix=1:nx
            x = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)
            mandelbrot[ix, iy] = mandel(x+im*y) 
        end  
    end
    
    for iy=1:ny
        for ix=1:nx
            if mandelbrot[ix,iy] == maxiter
                print(&quot;*&quot;)
            else
                print((mandelbrot[ix,iy]+9) ÷ 10)
            end
        end
        println(&quot;\t&quot;)
    end
end
mandel_main()</code></pre><p>となります。</p><p>一つ目のFortran90コードで気をつけたポイントの他には、</p><ol><li><code>MODULE</code>は<code>module</code>に。モジュールの名前はJuliaでは最初の一文字を大文字にする慣例があるのでそれにならった</li><li><code>USE m_mandel</code>は<code>using .M_mandel</code>に。関数の中ではなく、外に定義する</li><li>Fortranではモジュール内で宣言した変数や関数はデフォルトで<code>share</code>属性を持っており<code>use</code>ですぐに使えるが、Juliaの場合に同様にしたい場合には<code>export</code>をモジュール内で使っておく。使わない場合は<code>M_mandel.mandel(x+im*y)</code>とアクセスすることになる</li></ol><p>ということに気をつけました。</p><h3 id="Fortran2003"><a class="docs-heading-anchor" href="#Fortran2003">Fortran2003</a><a id="Fortran2003-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran2003" title="Permalink"></a></h3><p>次は、同じ<a href="https://qiita.com/cure_honey/items/795bd0e048ffeadc3e63">記事</a>のFortran2003のコードをJuliaに移植してみます。Fortranのコードを引用すると</p><pre><code class="language-fortran hljs">program mandel
    implicit none
    integer, parameter :: maxiter = 90, nx = 61, ny = 31
    real   , parameter :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    character(len = 10), parameter :: text = &#39;|+o0O.@*#-&#39;  
    integer :: ix, iy, iter, mandelbrot(nx, ny) = 0, m(nx)  
    real, allocatable :: x(:), y(:)
    complex :: c(nx, ny), z(nx, ny) = (0.0, 0.0)
    x = [( (x1 - x0) / (nx - 1) * (ix - 1) + x0, ix = 1, nx )]
    y = [( (y1 - y0) / (ny - 1) * (iy - 1) + y0, iy = 1, ny )]
    forall (ix = 1:nx, iy = 1:ny) c(ix, iy) = cmplx(x(ix), y(iy))
    do iter = 0, maxiter
      where (abs(z) &lt;= 2.0) 
        z = z * z + c
        mandelbrot = mandelbrot + 1
      end where  
    end do

    do iy = 1, ny
      m = (mandelbrot(:, iy) + 8) / 10  + 1
      write(*, &#39;(61a1)&#39;) (text(m(ix):m(ix)), ix = 1, nx)  
    end do
    stop
end program mandel</code></pre><p>となります。このコードをコンパイルして実行すると、</p><pre><code class="nohighlight hljs">||||||||||||||||||||||||||||||+||||||||||||||||||||||||||||||
||||||||||||||||||||+++++++++++++++++++++||||||||||||||||||||
||||||||||||||||+++++++++++++++++++++++++++++||||||||||||||||
||||||||||||+++++++++++++++++++++++++++++++++++++||||||||||||
||||||||||+++++++++++++++++++++++++++++++++++++++++||||||||||
||||||||+++++++++++++++++++++++++++++++++++++++++++++||||||||
||||||+++++++++++++++++++++++++++++++++++++++++++++++++||||||
|||||+++++++++++++++++++++++++++++++++++++++++++++++++++|||||
||||++++++++++++++++++++++++o++++++++++++++++++++++++++++||||
|||++++++++++++++++++++++++---o+++++++++++++++++++++++++++|||
||+++++++++++++++++++00+ooo0-*o@*++++++++++++++++++++++++++||
||++++++++++++++++++++-------------@+++++++++++++++++++++++||
|+++++++++++++++++++o---------------++++++++++++++++++++++++|
|+++++++++++o-O-0O+o----------------o+++++++++++++++++++++++|
|++++++++o+o------------------------.+++++++++++++++++++++++|
----------------------------------0++++++++++++++++++++++++++
|++++++++o+o------------------------.+++++++++++++++++++++++|
|+++++++++++o-O-0O+o----------------o+++++++++++++++++++++++|
|+++++++++++++++++++o---------------++++++++++++++++++++++++|
||++++++++++++++++++++-------------@+++++++++++++++++++++++||
||+++++++++++++++++++00+ooo0-*o@@++++++++++++++++++++++++++||
|||++++++++++++++++++++++++---o+++++++++++++++++++++++++++|||
||||++++++++++++++++++++++++o++++++++++++++++++++++++++++||||
|||||+++++++++++++++++++++++++++++++++++++++++++++++++++|||||
||||||++++++++++++++++++++++++++++++++++++++++++++++++|||||||
||||||||+++++++++++++++++++++++++++++++++++++++++++++||||||||
||||||||||+++++++++++++++++++++++++++++++++++++++++||||||||||
||||||||||||++++++++++++++++++++++++++++++++++++|||||||||||||
||||||||||||||||+++++++++++++++++++++++++++++||||||||||||||||
||||||||||||||||||||+++++++++++++++++++++||||||||||||||||||||
||||||||||||||||||||||||||||||+||||||||||||||||||||||||||||||</code></pre><p>となります。</p><p>対応するJuliaのコードは</p><pre><code class="language-julia hljs">function mandel()
    maxiter = 90;nx = 61; ny = 31
    x0 = -2.0; x1 = 2.0; y0 = -2.0; y1 = 2.0

    text = &quot;|+o0O.@*#-&quot;
    z = zeros(ComplexF64,nx,ny)
    mandelbrot = zeros(Int64,nx,ny)

    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]
    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]
    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]
    for iter=0:maxiter
        for i=1:length(z)
            if abs(z[i]) &lt;= 2
                z[i] = z[i]*z[i]+c[i]
                mandelbrot[i] += 1
            end
        end
    end

    for iy=1:ny
        m = (mandelbrot[:, iy] .+ 8) .÷ 10  .+ 1
        [print(text[m[ix]:m[ix]]) for ix=1:nx]
        println(&quot;\t&quot;)
    end
end
mandel()</code></pre><p>です。Fortranでのwhere構文（配列の各要素に条件式を当てはめてループする構文）のJulia対応が分かりませんでしたので、仕方がないので<code>for</code>ループを使いました。ただし、そのまま書いても芸がありませんので、2次元配列のzなどを1次元配列として取り出す方法を使ってみました。Juliaでは2次元配列をメモリ格納順に並べた1次元のインデックスを用いて値を操作することができます。</p><p>今回は</p><ol><li>for文のリスト内包表記<code>[ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]</code>の使用</li><li>Fortranの<code>forall</code>の代わりに二重forループのリスト内包表記の使用</li><li>配列の各要素にまとめて演算するために<code>.</code>を使ったブロードキャストを使用（<code>m = (mandelbrot[:, iy] .+ 8) .÷ 10  .+ 1</code>）</li></ol><p>を行いました。</p><h3 id="Fortran2003-オブジェクト指向"><a class="docs-heading-anchor" href="#Fortran2003-オブジェクト指向">Fortran2003 オブジェクト指向</a><a id="Fortran2003-オブジェクト指向-1"></a><a class="docs-heading-anchor-permalink" href="#Fortran2003-オブジェクト指向" title="Permalink"></a></h3><p>次は、同じ記事のオブジェクト指向で書かれたFortranコードをJuliaに移植してみます。 コードは</p><pre><code class="language-fortran hljs">module m_bmp
    implicit none
    type :: t_bmp_file_header
      sequence                      ! 14bytes
      character(len = 2) :: bfType = &#39;BM&#39; !integer(2) :: bfType = transfer(&#39;BM&#39;, 0_2, 1) ! BitMap
      integer(4) :: bfSize          ! file size in bytes
      integer(2) :: bfReserved1 = 0 ! always 0
      integer(2) :: bfReserved2 = 0 ! always 0
      integer(4) :: bfOffBits
    end type t_bmp_file_header
    ! 
    type :: t_bmp_info_header 
      sequence
      integer(4) :: biSize     = Z&#39;28&#39; ! size of bmp_info_header ; 40bytes 
      integer(4) :: biWidth
      integer(4) :: biHeight
      integer(2) :: biPlanes   = 1 ! always 1
      integer(2) :: biBitCount
      integer(4) :: biCompression = 0 !0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield
      integer(4) :: biSizeImage
      integer(4) :: biXPelsPerMeter = 3780 ! 96dpi
      integer(4) :: biYPelsPerMeter = 3780 ! 96dpi 
      integer(4) :: biClrUsed      = 0
      integer(4) :: biClrImportant = 0 
    end type t_bmp_info_header  
    !
    type :: t_rgb
      sequence
      character :: b, g, r  ! order is b g r 
    end type t_rgb 
    !
    type :: t_bmp(nx, ny)
      integer, len:: nx, ny  
      type(t_rgb) :: rgb(nx, ny)
    contains 
      procedure :: wr =&gt; wr_bmp
      procedure :: pr_bmp
      generic :: write(formatted) =&gt; pr_bmp
    end type
  contains   
    subroutine wr_bmp(bmp, fn)
      class(t_bmp(*, *)), intent(in) :: bmp
      character(len = *), intent(in) :: fn
      type(t_bmp_file_header) :: bmp_file_header
      type(t_bmp_info_header) :: bmp_info_header
      bmp_file_header%bfSize      = 14 + bmp_info_header%biSize + 0 + bmp%nx * bmp%ny * 3
      bmp_file_header%bfOffBits   = 14 + bmp_info_header%biSize
      bmp_info_header%biWidth     = bmp%nx       ! nx shouold be a multiple of 4
      bmp_info_header%biHeight    = bmp%ny
      bmp_info_header%biBitCount  = 24           ! color depth 24bits
      bmp_info_header%biSizeImage = bmp%nx * bmp%ny * 3
      open(9, file = fn//&#39;.bmp&#39;, form = &#39;binary&#39;, status = &#39;unknown&#39;)
      write(9) bmp_file_header
      write(9) bmp_info_header
      write(9) bmp%rgb
      close(9)
      return
    end subroutine wr_bmp
! convert to t_RGB    
    pure elemental type(t_rgb) function to_rgb(ir, ig, ib)
      integer, intent(in) :: ir, ig, ib
      to_rgb = t_rgb(achar(ib), achar(ig), achar(ir))
    end function to_rgb  

    subroutine pr_bmp(dtv, unit, iotype, vlist, io, iomsg)
      class(t_bmp(*, *)), intent(in) :: dtv
      integer, intent(in) :: unit
      character(len = *), intent(in) :: iotype
      integer, intent(in) :: vlist(:)
      integer, intent(out) :: io
      character(len = *), intent(in out) :: iomsg
      character(len = 30) :: fmt
      if (iotype == &#39;LISTDIRECTED&#39;) then
        write(unit, *, iostat = io) &#39;nx =&#39;, dtv%nx, &#39;, ny =&#39;, dtv%ny
      end if    
    end subroutine pr_bmp
  end module m_bmp

  module m_mandel
    implicit none
    integer, parameter :: maxiter = 254
  contains
    pure elemental integer function mandel(c)
      complex, intent(in) :: c
      complex :: z
      z = (0.0, 0.0)
      do mandel = 0, maxiter
        z = z * z + c
        if (abs(z) &gt; 2.0) exit
      end do    
    end function mandel 
  end module m_mandel

  program mandel_main
    use m_bmp
    use m_mandel 
    implicit none
    integer, parameter :: nx = 640, ny = 640
    real   , parameter :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    integer :: ix, iy, iter, mandelbrot(nx, ny)
    real    :: x(nx), y(ny)
    complex :: c(nx, ny)
    type(t_bmp(nx, ny)) :: bmp 
!
    forall (ix = 1:nx) x(ix) = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)
    forall (iy = 1:ny) y(iy) = y0 + (y1 - y0) * (iy - 1) / real(ny - 1)
    forall (ix = 1:nx, iy = 1:ny) c(ix, iy) = cmplx(x(ix), y(iy))
    mandelbrot = mandel(c)  
!
    bmp%rgb = to_rgb(255 - mandelbrot, 255 - mandelbrot, 255 - mandelbrot)
    call bmp%wr(&#39;test&#39;)
    print *, &#39;BMP size: &#39;, bmp
    stop 
  end program mandel_main</code></pre><p>です。このコードですが、gfortranでコンパイルしようとしても失敗してしまいました。<a href="https://fortran-lang.discourse.group/t/a-gfortran-issue-with-parameterized-derived-types/213">こちら</a>によると、どうやら「Fortran2003 で導入されたパラメータ付派生型(parameterized derived type)」がgfortranがこの機能にフルに対応していないようです。ですので、このコードの実行を確認できていません。</p><h4 id="追記"><a class="docs-heading-anchor" href="#追記">追記</a><a id="追記-1"></a><a class="docs-heading-anchor-permalink" href="#追記" title="Permalink"></a></h4><p>2020年12月からIntelのFortranコンパイラであるifortが無料で使えるようになっていたようです。<a href="https://qiita.com/implicit_none/items/35bc4be8f2022903747a">こちら</a>を参照してインストールしてみたところ、無事に上のコードをコンパイルできました。なお、Macでやる時には<a href="https://community.intel.com/t5/Intel-Fortran-Compiler/New-macOS-Big-Sur-return-quot-ld-library-not-found-for-lSystem/m-p/1228382/highlight/true?profile.language=ja">こちら</a>にあるように「 -L/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib」をつける必要があるかもしれません（LIBRARY_PATHにこれを追加しておく）。</p><p>記事によると、このコードは画像をBMP形式で出力してくれるようです。BMPのフォーマットは検索すると出てきましたので、その形式に従ってバイナリを出力する、というコードのようです。</p><p>これのJulia版は</p><pre><code class="language-julia hljs">module M_bmp
    export to_rgb,T_bmp,wr_bmp

    Base.@kwdef mutable struct T_bmp_file_header
        bfType::String = &quot;BM&quot; 
        bfSize::Int32 = 0
        bfReserved1::Int16 = 0
        bfReserved2::Int16 = 0
        bfOffBits::Int32 = 0
    end

    Base.@kwdef mutable struct T_bmp_info_header 
        biSize::Int32 = 0x28
        biWidth::Int32 = 0
        biHeight::Int32 = 0
        biPlanes::Int16   = 1 
        biBitCount::Int16 = 0
        biCompression::Int32 = 0 #0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield
        biSizeImage::Int32 = 0
        biXPelsPerMeter::Int32 = 3780 # 96dpi
        biYPelsPerMeter::Int32 = 3780 # 96dpi 
        biClrUsed::Int32      = 0
        biClrImportant::Int32 = 0 

    end

    mutable struct T_rgb
        b::UInt8
        g::UInt8
        r::UInt8
    end

    Base.@kwdef mutable struct T_bmp{nx,ny}
        rgb::Array{T_rgb,2} = Array{T_rgb,2}(undef,nx,ny)
    end

    function Base.write(fp::IO,data::T_bmp_file_header)
        write(fp,data.bfType)
        write(fp,data.bfSize)
        write(fp,data.bfReserved1)
        write(fp,data.bfReserved2)
        write(fp,data.bfOffBits)
    end

    function Base.write(fp::IO,data::T_bmp_info_header)
        write(fp,data.biSize)
        write(fp,data.biWidth)
        write(fp,data.biHeight)
        write(fp,data.biPlanes)
        write(fp,data.biBitCount)
        write(fp,data.biCompression)
        write(fp,data.biSizeImage)
        write(fp,data.biXPelsPerMeter)
        write(fp,data.biYPelsPerMeter)
        write(fp,data.biClrUsed)
        write(fp,data.biClrImportant)
    end

    function Base.write(fp::IO,data::T_rgb)
        write(fp,data.b)
        write(fp,data.g)
        write(fp,data.r)
    end

    function Base.write(fp::IO,data::T_bmp{nx,ny}) where {nx,ny}
        for iy=1:ny
            for ix=1:nx
                #println(data.rgb[ix,iy])
                write(fp,data.rgb[ix,iy])
            end
        end
    end

    function wr_bmp(bmp::T_bmp{nx,ny}, fn) where {nx,ny}
        bmp_info_header = T_bmp_info_header()
        bmp_file_header = T_bmp_file_header()
        bmp_file_header.bfSize      = 14 + bmp_info_header.biSize + 0 + nx * ny * 3
        bmp_file_header.bfOffBits   = 14 + bmp_info_header.biSize
        bmp_info_header.biWidth     = nx       # nx shouold be a multiple of 4
        bmp_info_header.biHeight    = ny
        bmp_info_header.biBitCount  = 24           # color depth 24bits
        bmp_info_header.biSizeImage = nx * ny * 3
        fp = open(fn*&quot;.bmp&quot;,&quot;w&quot;)
        write(fp,bmp_file_header)
        write(fp,bmp_info_header)
        write(fp,bmp)
    end

    function to_rgb(ir,ig,ib)
        return T_rgb(htol(ir),htol(ig),htol(ib))
    end
end

module M_mandel
    const maxiter = 254
    export mandel,maxiter

    function mandel(c)
        z = 0im
        count = maxiter
        for i=0:maxiter
            z = z * z + c
            if abs(z) &gt; 2
                count = i
                break
            end
        end
        return count
    end
end


using .M_bmp
using .M_mandel

function mandel_main()
    nx = 640;ny = 640
    x0 = -2.0;x1 = 2.0; y0 = -2.0; y1 = 2.0
    bmp = T_bmp{nx,ny}()

    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]
    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]
    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]
    mandelbrot = mandel.(c)

    bmp.rgb = to_rgb.(255 .- mandelbrot,255 .- mandelbrot,255 .- mandelbrot)
    wr_bmp(bmp,&quot;test&quot;)
    println(&quot;BMP size:  $nx $ny&quot;)
end

mandel_main()</code></pre><p>となります。 実行した結果は得られる画像は</p><p><img src="../test.bmp" alt="fig1"/></p><p>となります。</p><p>ポイントは</p><ol><li>Fortran2003のオブジェクト指向によるクラスはJuliaでは<code>mutable struct</code>に。また、クラスのメソッドはJuliaでは多重ディスパッチで定義。</li><li>Fortranでは定義した構造体をそのままバイナリで書き出せたが、Juliaでの独自型は自分で書き出しを指定してやる必要があるため、標準のwriteを多重ディスパッチで機能拡張</li><li>BMP形式の定義によると<code>t_rgb</code>クラスに入れるべきは符号なし整数なので、Juliaでは<code>UInt8</code>型（符号なし8ビット整数）に変更</li><li><code>mutable struct</code>でデフォルトの値を入れるために<code>Base.@kwdef</code>を使用</li><li>Fortranでのパラメータ付派生型と同等の機能をJuliaではパラメトリック型で実装（<code>mutable struct T_bmp{nx,ny}</code>）</li></ol><p>です。オブジェクト指向なコードもすんなりJuliaに移植できました。</p><h3 id="パッケージの利用"><a class="docs-heading-anchor" href="#パッケージの利用">パッケージの利用</a><a id="パッケージの利用-1"></a><a class="docs-heading-anchor-permalink" href="#パッケージの利用" title="Permalink"></a></h3><p>上で書いたJuliaのコードはFortranでBMP形式を扱うように直接バイナリを操作したものでした。Juliaの場合、自前で書かなくても関連するパッケージがあり、簡単に画像データを扱えます。ここではImagesというパッケージを使います。これをインストールするには、</p><pre><code class="nohighlight hljs">julia -e &#39;using Pkg;Pkg.add(&quot;Images&quot;)&#39;</code></pre><p>としてください。 これを使うと、</p><pre><code class="language-julia hljs">module M_mandel
    const maxiter = 254
    export mandel,maxiter

    function mandel(c)
        z = 0im
        count = maxiter
        for i=0:maxiter
            z = z * z + c
            if abs(z) &gt; 2
                count = i
                break
            end
        end
        return count
    end
end

using .M_mandel
using Images

function mandel_main()
    nx = 640;ny = 640
    x0 = -2.0;x1 = 2.0; y0 = -2.0; y1 = 2.0

    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]
    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]
    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]
    mandelbrot = mandel.(c)
    img = (255 .- mandelbrot)/255
    save(&quot;test2.bmp&quot;,img&#39;)
    save(&quot;test2.png&quot;,img&#39;)

    println(&quot;BMP size:  $nx $ny&quot;)
end
mandel_main()</code></pre><p>とすれば、BMP形式とPNG形式のグレースケールの画像を出力できます。</p><p>ここでの追加のポイントとしては</p><ol><li>グレースケール画像は0から1の範囲なので、255で割っている。</li><li>行列を可視化するような形に出力されるため、デフォルトではxが下方向、yが右方向になっている。これを変更するために、<code>img</code>を<code>&#39;</code>で転置した。</li></ol><p>です。Fortranと異なりJuliaはモダンな言語ですから、画像や動画の扱いが容易です。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../chapter1/02/">« 線形代数計算</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Saturday 21 August 2021 16:52">Saturday 21 August 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
