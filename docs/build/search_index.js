var documenterSearchIndex = {"docs":
[{"location":"chapter1/02/#線形代数計算","page":"線形代数計算","title":"線形代数計算","text":"","category":"section"},{"location":"chapter1/02/#行列やベクトルの定義","page":"線形代数計算","title":"行列やベクトルの定義","text":"","category":"section"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"Fortranでは行列やベクトルの定義の方法についてです。配列の定義方法について比較してきましょう。Fortranでは配列の定義は","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"real(8)::d(1:3,1:4)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"のような形で書きますね（他の書き方は省略）。この場合はdは倍精度実数が要素の2次元配列です。この配列の中身は決まっていませんので、通常は","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"d = 0d0","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"などと初期化します。Juliaの場合、0で初期化した2次元配列が必要な場合","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"d = zeros(Float64,3,4)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"と書きます。もし、Fortranと同じように初期化されていない配列が欲しい場合には、","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"d = Array{Float64,2}(undef,3,4)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"と書きます。Array{Float64,2}の2は配列の次元を示し、(undef,3,4)の3,4はそれぞれの次元の要素数を示します。","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"倍精度複素数の3次元配列が欲しい場合は、Fortranであれば","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"complex(8)::f(1:2,1:3,1:5)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"で定義できます。Juliaであれば","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"f = zeros(ComplexF64,2,3,5)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"となります。","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"Fortranではallocatableを使えば","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"real(8),allocatable::d(:,:)\nallocate(d(1:3,1:4))","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"というような形で、実行時に動的に配列の形状を決めることができていました。Juliaのzeros(Float64,3,4)やArray{Float64,2}(undef,3,4)などはこれと同じように動的に配列の形状を決めていると考えても構いません。両者はよく似ています。","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"Fortranの場合、配列の始まりと終わりを好きなように決めることができました。例えば、","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"real(8)::d(1:2,3:9)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"というdを定義すると、1次元目の添字の範囲は1から2、2次元目の添字の範囲が3から9の配列を定義することができます。Juliaではデフォルトではこのような添字の範囲を設定することはできません。しかし、JuliaのパッケージにはOffsetArraysというパッケージがありまして、これを使うことで同じことが可能となります。例えば、上のような配列の場合には","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"using OffsetArrays\nc = Array{Float64,2}(undef,2,7)\nd = OffsetArray(c, 1:2, 3:9)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"とすればdの添字の範囲はFortranと同じになります。なお、OffsetArraysを使って通常の配列cからdを作成する時にメモリのコピーは発生しておりませんので、追加のコストはほとんどかかりません。","category":"page"},{"location":"chapter1/02/#初期値について","page":"線形代数計算","title":"初期値について","text":"","category":"section"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"Juliaでは、作った配列の初期値をあらかじめ0とする","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"a = zeros(Float64,2,3)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"の他に、全部1にする","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"b = zeros(Int64,2,3)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"があります。また、乱数での初期化として","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"c = rand(2,3)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"も可能です。乱数は0から1の間の数が出ます。なお、乱数のシードは","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"using Random\nn = 123\nRandom.seed!(n)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"で固定できます。nを変えると異なる乱数列が出ます。nが同じの場合には常に同じ数列が出力されますから、デバッグなどでは重要です。","category":"page"},{"location":"chapter1/02/#基本的な演算","page":"線形代数計算","title":"基本的な演算","text":"","category":"section"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"Fortranも行列やベクトルの演算に強いですが、Juliaも強いです。例えば、Fortranでは","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"y = matmul(A,x)\nC = matmul(A,B)","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"などで、y = AxやC = ABが計算できます。ここで大文字は行列、小文字はベクトルを想定しました。Juliaでは","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"y = A*x\nC = A*B","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"とただの掛け算記号でかけます。もちろん、足し算もできて、ベクトル同士の足し算は","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"y = A*x + b","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"でできます。","category":"page"},{"location":"chapter1/02/#線形代数関連","page":"線形代数計算","title":"線形代数関連","text":"","category":"section"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"Fortranで連立方程式を解いたり逆行列を計算したり特異値分解をしたり固有値を求めたりする場合には、LAPACKをインストールして使うと思います。Juliaでは標準機能でこれらを実行できます。まず、線形代数関連のパッケージを使うため、","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"using LinearAlgebra","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"とします。連立方程式b = Axのxを求めたい場合には","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"y = rand(2,2)\nb = rand(2,2)\nx = A \\ b","category":"page"},{"location":"chapter1/02/","page":"線形代数計算","title":"線形代数計算","text":"ですぐ求まります。","category":"page"},{"location":"chapter2/02/#FortranでできることをJuliaでやってみる","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"","category":"section"},{"location":"chapter2/02/#namelist","page":"FortranでできることをJuliaでやってみる","title":"namelist","text":"","category":"section"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"Fortranではnamelistという機能があり、こちらにありますように、インプットファイルを一行で読み込めてしまいます。 例えば、このソフトウェアでも使われています。 使用方法は","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"program main\n    implicit none\n    integer::nx,ny,nz,n\n    real(8)::qx,qy,qz\n    character(100) :: filename1,filename2\n\n    namelist /dim/nx,ny,nz,filename1\n    namelist /dimq/n,qx,qy,qz,filename2\n    \n\n    open(11,file=\"testinput.txt\",status='old',action='read')\n    read(11,nml=dim)\n    write(*,nml=dim)\n    read(11,nml=dimq)\n    write(*,nml=dimq)\n    close(11)\n\nend program main","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"とします。そして、インプットファイルは","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"&dim\nnx = 3,\nny = 3,\nnz = 9,\nfilename1 = \"filename1dayo\",\n&end\n\n&dimq\nn = 10,\nqx = 3d0,\nqy = 3d0,\nqz = 9d0,\nfilename2 = \"filename2dayo\",\n&end\n/","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"です。一行でパラメータを読み込めるので便利ですね。このインプットファイルをJuliaでも読み込んでみることをやってみます。","category":"page"},{"location":"chapter2/02/#PyCall経由でのPythonライブラリの使用","page":"FortranでできることをJuliaでやってみる","title":"PyCall経由でのPythonライブラリの使用","text":"","category":"section"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"まず、Fortranのnamelistをいい感じに取り扱うパッケージがJuliaにないかを探してみましたが、現時点(2021年8月)の時点で見つかりませんでした。しかし、Pythonのライブラリのf90nmlを見つけました。JuliaではPyCallを使えばPythonのライブラリを簡単に使うことができます。 PyCallのインストールは","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"julia -e 'using Pkg;Pkg.add(\"PyCall\")'","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"です。その後、f90nmlを入れるために、","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"using PyCall\n@pyimport pip\npip.main([\"install\",\"f90nml\"])","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"を実行します。これでf90nmlがJuliaで使えるようになりました。インストールが終わりましたので、使う時には","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"using PyCall\nf90nml = pyimport(\"f90nml\")","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"でOKです。あとは","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"testdata = f90nml.read(\"testinput.txt\")","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"とすると、辞書型としてファイルを読み込むことができます。つまり、","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"nx = testdata[\"dim\"][\"nx\"]","category":"page"},{"location":"chapter2/02/","page":"FortranでできることをJuliaでやってみる","title":"FortranでできることをJuliaでやってみる","text":"のような形でデータを取り出せます。","category":"page"},{"location":"chapter1/01/#FortranとJuliaの文法比較","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"","category":"section"},{"location":"chapter1/01/#演算子","page":"FortranとJuliaの文法比較","title":"演算子","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"FortranとJuliaの演算子その他について比較してみましょう。ほとんど同じですが、一部だけ異なります。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"定義 Fortran Julia\na+b a+b a+b\na-b a-b a-b\na times b a*b a*b\na div b a/b a/b(実数)、div(a,b)(商（整数）)、a÷b(divと同じ。入力は\\divで。)\na div bの余り mod(a,b) a % b\na^b a**b a^b\nsin a  cos b sin(a),cos(b) sin(a),cos(b)\na abs(a) abs(a)\nsqrta sqrt(a) sqrt(a)\ne^a exp(a) exp(a)\nlog a log(a) log(a)\n6 times 10^-4 (倍精度) 6d-4 6e-4\nzの複素共役 conjg(z) conj(z)\nrm Rez dble(z) real(z)\nrm Imz dimag(z) imag(z)\nrm Max(ab) max(a,b) max(a,b)","category":"page"},{"location":"chapter1/01/#繰り返しループ","page":"FortranとJuliaの文法比較","title":"繰り返しループ","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"do i=1,5\nend do","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"というdoループが用いられますが、対応するJuliaのループはforを使って、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"for i=1:5\nend","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"ループの途中で抜けたい場合、Fortranではexitを、Juliaではbreakを使います。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"ループの次の反復ステップに行きたい場合には、Fortranではcycleを、Juliaではcontinueを使います。","category":"page"},{"location":"chapter1/01/#If文","page":"FortranとJuliaの文法比較","title":"If文","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"条件分岐にはどちらもIf文を使います。Fortranでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"if (a > b) then\nelse if(a < b) then\nelse\nendif","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"のような形で書きますが、Juliaでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"if a > b\nelseif a < b\nelse\nend","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。条件比較に使う比較演算子の違いをテーブルにまとめると","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"FORTRAN77 Fortran Julia\na .lt. b a < b a < b\na .le. b a <= b a <= b\na .eq. b a == b a == b\na .ne. b a /= b a != b\na .gt. b a > b a > b\na .ge. b a >= b a >= b","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"となります。複数の条件を使う場合の違いは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"定義 Fortran Julia\naかつb a .and. b a && b\naまたはb a .or. b a || b","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"です。","category":"page"},{"location":"chapter1/01/#型の対応","page":"FortranとJuliaの文法比較","title":"型の対応","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranでは変数の型を定義しなければコンパイルエラーが起きますが、Juliaの場合は型を意識せずにコーディングすることができます。一方、内部ではJuliaはやはり型を扱っていますから、Fortran使用者はFortranとJuliaの型の対応を知っておくと理解しやすいでしょう。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"種類 Fortran Julia\n倍精度実数 real*8やreal(8) Float64\n単精度実数 realやreal(4) Float32\n32ビット符号付き整数 integer(機種依存及びコンパイルオプション依存)やinteger(4) Int32\n64ビット符号付き整数 integer(機種依存及びコンパイルオプション依存)やinteger(8) Int64\n倍精度複素数 complex*16やcomplex(8) ComplexF64\n単精度複素数 complexやcomplex(4) ComplexF32\n論理値 logical Bool\n文字データ character String","category":"page"},{"location":"chapter1/01/#配列の型と定義","page":"FortranとJuliaの文法比較","title":"配列の型と定義","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranは科学技術計算用のプログラミング言語ですから、行列やベクトルを表現する配列の操作が（他の同じ歴史の長いプログラミング言語等よりも）容易です。一方、Juliaも科学技術計算用として作られていますから、当然、配列の操作も容易です。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"それでは、まず配列の定義方法について比較してきましょう。Fortranでは配列の定義は","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"real(8)::d(1:3,1:4)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"のような形で書きますね（他の書き方は省略）。この場合はdは倍精度実数が要素の2次元配列です。この配列の中身は決まっていませんので、通常は","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"d = 0d0","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"などと初期化します。Juliaの場合、0で初期化した2次元配列が必要な場合","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"d = zeros(Float64,3,4)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。もし、Fortranと同じように初期化されていない配列が欲しい場合には、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"d = Array{Float64,2}(undef,3,4)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。Array{Float64,2}の2は配列の次元を示し、(undef,3,4)の3,4はそれぞれの次元の要素数を示します。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"倍精度複素数の3次元配列が欲しい場合は、Fortranであれば","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"complex(8)::f(1:2,1:3,1:5)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"で定義できます。Juliaであれば","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"f = zeros(ComplexF64,2,3,5)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"となります。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranではallocatableを使えば","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"real(8),allocatable::d(:,:)\nallocate(d(1:3,1:4))","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"というような形で、実行時に動的に配列の形状を決めることができていました。Juliaのzeros(Float64,3,4)やArray{Float64,2}(undef,3,4)などはこれと同じように動的に配列の形状を決めていると考えても構いません。両者はよく似ています。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranの場合、配列の始まりと終わりを好きなように決めることができました。例えば、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"real(8)::d(1:2,3:9)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"というdを定義すると、1次元目の添字の範囲は1から2、2次元目の添字の範囲が3から9の配列を定義することができます。Juliaではデフォルトではこのような添字の範囲を設定することはできません。しかし、JuliaのパッケージにはOffsetArraysというパッケージがありまして、これを使うことで同じことが可能となります。例えば、上のような配列の場合には","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"using OffsetArrays\nc = Array{Float64,2}(undef,2,7)\nd = OffsetArray(c, 1:2, 3:9)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"とすればdの添字の範囲はFortranと同じになります。なお、OffsetArraysを使って通常の配列cからdを作成する時にメモリのコピーは発生しておりませんので、追加のコストはほとんどかかりません。","category":"page"},{"location":"chapter1/01/#出力","page":"FortranとJuliaの文法比較","title":"出力","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranで画面に書き出したい場合には","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"write(*,*) \"a = \",a","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"のように書きます。Juliaでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"println(\"a = \",a)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"あるいは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"println(\"a = $a\")","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。$aと書くと変数を文字列に変えることができます。また、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"write(*,*) \"a = \",2*a","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"であれば、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"println(\"a = $(2*a)\")","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書けます。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"ファイルに出力する場合、Fortranでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"open(10,file=\"test.txt\")\nwrite(10,*) \"a = \",2*a\nclose(10)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"のように装置番号を指定してファイルを開きますが、Juliaでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"fp = open(\"test.txt\",\"w\")\nprintln(fp,\"a = $(2*a)\")\nclose(fp)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。","category":"page"},{"location":"chapter1/01/#入力","page":"FortranとJuliaの文法比較","title":"入力","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"テキストファイルtest.txtが","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"           1   3.0000000000000000     \n           2   6.0000000000000000     \n           3   9.0000000000000000     \n           4   12.000000000000000   ","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"というデータだとしましょう。このファイルからデータを読み込む場合、Fortranでは、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"    open(12,file=\"test.txt\")\n    do i=1,4\n        read(12,*) j,x\n        write(*,*) j,x\n    end do\n    close(12)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"とすることで読み込むことができます。Juliaの場合には、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"data = readlines(\"test.txt\")\nfor i=1:4\n    u = split(data[i])\n    j = parse(Int64,u[1])\n    x = parse(Float64,u[2])\n    println(\"$j $x\")\nend","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"で読み込めます。Juliaではこのreadlineを使うやり方の他にも読み込みの方法がありますが、ここでは使い勝手の良いこの方法のみを紹介することとします。","category":"page"},{"location":"chapter1/01/#配列へのアクセス","page":"FortranとJuliaの文法比較","title":"配列へのアクセス","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranでは配列aのi,j成分にアクセスするには","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"a(i,j)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きますが、Juliaでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"a[i,j]","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"と書きます。 配列のメモリへの格納順はFortranとJuliaでは同じになっており、行列で言うところの列の単位で格納されています（一番左の添字が一番内側）。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"配列の一部分へのアクセスもよく似ており、Fortranでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"a(1:4,1:5)","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"となり、Juliaでは","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"a[1:4,1:5]","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"となります。","category":"page"},{"location":"chapter1/01/#関数","page":"FortranとJuliaの文法比較","title":"関数","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranでは返り値が一つある場合にはfunctionを、返り値がない場合にはsubroutineを使っていました。Juliaでは両方ともfunctionです。定義の仕方はいくつか方法があります。例えば、c=a+bという計算は","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"function test(a,b)\n    c = a+b\n    return c\nend\n\nfunction test(a,b)\n    c = a+b\nend\n\ntest(a,b) = a+b","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"が可能です。return文がない場合には、最後の行がreturnとして返されることになっています。返り値が複数の場合は","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"function test2(a,b)\n    c = a+b\n    d = a*b\n    return c,d\nend","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"のように書きます。","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"Fortranにおいて、functionを使った場合、左辺に右辺の値が代入する形になります(c = test(a,b))。これはJuliaも同様です。しかし、配列を扱うときは右辺に値を生成するとコピーが発生してしまうので、これを避けるためにはFortranではsubroutineを使っていました。同様のことはJuliaでも可能です。例えば、Fortranで","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"module m_test\n    contains\n    subroutine testsub(c,b)\n        implicit none\n        real(8),intent(out)::c(:)\n        real(8),intent(in)::b\n        c(1) = b\n    end subroutine\nend module\nprogram main\n    use m_test\n    implicit none\n    real(8)::val(1:4)\n\n    val = 0d0\n    call testsub(val,3d0)\n    write(*,*) val\nend program","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"というコードを考えます。サブルーチンtestsub(c,b)は引数のcの値を変更します。 これをJuliaで書きますと、","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"function testsub!(c,b)\n    c[1] = b\nend\n\nfunction main()\n    val = zeros(Float64,4)\n    testsub!(val,3)\n    println(val)\nend\nmain()","category":"page"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"となります（ここではあえてモジュールを使いませんでした。モジュールについては後述します）。Juliaでは引数の値を変更するときは慣例的に関数名の最後に!をつけます。","category":"page"},{"location":"chapter1/01/#モジュール","page":"FortranとJuliaの文法比較","title":"モジュール","text":"","category":"section"},{"location":"chapter1/01/","page":"FortranとJuliaの文法比較","title":"FortranとJuliaの文法比較","text":"FortranもJuliaもモジュールという機能があります。","category":"page"},{"location":"chapter2/01/#FortranのコードをJuliaへ移植してみる","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"","category":"section"},{"location":"chapter2/01/#マンデルブロ集合","page":"FortranのコードをJuliaへ移植してみる","title":"マンデルブロ集合","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"こちらの記事にはさまざまなFortranのバージョンで書かれたマンデルブロ集合のコードが紹介されています。","category":"page"},{"location":"chapter2/01/#Fortran90","page":"FortranのコードをJuliaへ移植してみる","title":"Fortran90","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"この記事の中のFortran90のコードを引用します。コードは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"PROGRAM mandel\n    IMPLICIT NONE\n    INTEGER, PARAMETER :: nx = 61, ny = 31, maxiter = 90\n    REAL   , PARAMETER :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0\n    INTEGER :: ix, iy, iter, mandelbrot(nx, ny)\n    REAL :: x, y\n    COMPLEX :: z, c\n    DO iy = 1, ny\n      y = y0 + (y1 - y0) * (iy - 1) / REAL(ny - 1) \n      DO ix = 1, nx\n        x = x0 + (x1 - x0) * (ix - 1) / REAL(nx - 1)  \n        c = CMPLX(x, y)\n        z = (0.0, 0.0)\n        DO iter = 0, maxiter\n          z = z * z + c\n          IF (ABS(z) > 2.0) EXIT\n        END DO    \n        mandelbrot(ix, iy) = iter\n      END DO    \n    END DO\n!\n    DO iy = 1, ny     \n      PRINT '(61I1)', (mandelbrot(:, iy) + 9) / 10 \n    END DO          \n    STOP\nEND PROGRAM mandel","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"です。このコードをgfortranでコンパイルし、実行しますと、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"0000000000000000000000000000001000000000000000000000000000000\n0000000000000000000011111111111111111111100000000000000000000\n0000000000000000111111111111111111111111111110000000000000000\n0000000000001111111111111111111111111111111111111000000000000\n0000000000111111111111111111111111111111111111111110000000000\n0000000011111111111111111111111111111111111111111111100000000\n0000001111111111111111111111111111111111111111111111111000000\n0000011111111111111111111111111111111111111111111111111100000\n0000111111111111111111111111211111111111111111111111111110000\n000111111111111111111111111***2111111111111111111111111111000\n0011111111111111111113312223*72671111111111111111111111111100\n0011111111111111111111*************61111111111111111111111100\n011111111111111111112***************1111111111111111111111110\n0111111111112*4*3412****************2111111111111111111111110\n011111111212************************5111111111111111111111110\n**********************************311111111111111111111111111\n011111111212************************5111111111111111111111110\n0111111111112*4*3412****************2111111111111111111111110\n011111111111111111112***************1111111111111111111111110\n0011111111111111111111*************61111111111111111111111100\n0011111111111111111113312223*72661111111111111111111111111100\n000111111111111111111111111***2111111111111111111111111111000\n0000111111111111111111111111211111111111111111111111111110000\n0000011111111111111111111111111111111111111111111111111100000\n0000001111111111111111111111111111111111111111111111111000000\n0000000011111111111111111111111111111111111111111111100000000\n0000000000111111111111111111111111111111111111111110000000000\n0000000000001111111111111111111111111111111111111000000000000\n0000000000000000111111111111111111111111111110000000000000000\n0000000000000000000011111111111111111111100000000000000000000\n0000000000000000000000000000001000000000000000000000000000000","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"という出力が得られます。この出力を再現するようなJuliaのコードを書いてみましょう。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"作ったJuliaのコードは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"function mandel()\n    nx = 61; ny = 31; maxiter = 90\n    x0 = -2.0; x1 = 2.0; y0 = -2.0; y1 = 2.0\n    mandelbrot = zeros(Int64,nx, ny)\n    mandelbrot .= maxiter\n    for iy=1:ny\n        y = y0 + (y1 - y0) * (iy - 1) / real(ny - 1) \n        for ix=1:nx\n            x = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)\n            c = x + im*y\n            z = 0im\n            for iter=0:maxiter\n                z = z * z + c\n                if abs(z) > 2\n                    mandelbrot[ix,iy] = iter\n                    break\n                end\n            end\n            \n        end\n    end\n    for iy=1:ny\n        for ix=1:nx\n            if mandelbrot[ix,iy] == maxiter\n                print(\"*\")\n            else\n                print((mandelbrot[ix,iy]+9) ÷ 10)\n            end\n        end\n        println(\"\\t\")\n    end\nend\nmandel()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"です。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"ポイントは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"program mandelをfunction mandel()に変更\n;を使い一行に複数の文を入れた\n配列mandelbrotをmandelbrot = zeros(Int64,nx, ny)で定義\nFortranでループを抜けるexitは、対応するbreakに変更\nFortranはdo iter = 0, maxiterのループの途中で抜けた場合iterには抜けた時の値が入っているが、Juliaではiterのスコープがローカルなので外では未定義になっている。そのため、mandelbrot[ix,iy] = iterとした\niterのループが最大まで到達した時に、Fortranではmandelbrot(ix, iy)の中身はループの最後の値maxiterになるが、Juliaでは前述のようにiterはローカルスコープの変数なので値が入らない。なので、最初にmandelbrot .= maxiterと初期化した","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"などです。見比べるとはっきりとわかりますが、Fortran90のコードとJuliaのコードはよく似ています。","category":"page"},{"location":"chapter2/01/#Fortran90-モジュールを使用","page":"FortranのコードをJuliaへ移植してみる","title":"Fortran90 モジュールを使用","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"次は、モジュールを使用したコードをJuliaコードに変化させてみます。 コードはこちらの記事からの引用しまして、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"MODULE m_mandel\n    IMPLICIT NONE\n    INTEGER, PARAMETER :: maxiter = 90\n  CONTAINS\n    INTEGER FUNCTION mandel(c)\n      COMPLEX, INTENT(IN) :: c\n      COMPLEX :: z\n      z = (0.0, 0.0)\n      DO mandel = 0, maxiter\n        z = z * z + c\n        IF (ABS(z) > 2.0) EXIT\n      END DO    \n    END FUNCTION mandel \n  END MODULE m_mandel\n\n  PROGRAM mandel_main\n    USE m_mandel\n    IMPLICIT NONE\n    INTEGER, PARAMETER :: nx = 61, ny = 31\n    REAL   , PARAMETER :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0\n    INTEGER :: ix, iy, iter, mandelbrot(nx, ny)\n    REAL :: x, y\n    DO iy = 1, ny\n      y = y0 + (y1 - y0) * (iy - 1) / REAL(ny - 1)   \n      DO ix = 1, nx\n        x = x0 + (x1 - x0) * (ix - 1) / REAL(nx - 1)  \n        mandelbrot(ix, iy) = mandel(CMPLX(x, y)) \n      END DO    \n    END DO\n!\n    DO iy = 1, ny\n      PRINT '(61i1)', (mandelbrot(:, iy) + 9) / 10  \n    END DO    \n    STOP\n  END PROGRAM mandel_main","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"というものです。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"このコードをJuliaに移植してみますと、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"module M_mandel\n    const maxiter = 90\n    export mandel,maxiter\n\n    function mandel(c)\n        z = 0im\n        count = maxiter\n        for i=0:maxiter\n            z = z * z + c\n            if abs(z) > 2\n                count = i\n                break\n            end\n        end\n        return count\n    end\nend\n\nusing .M_mandel\nfunction mandel_main()\n    nx = 61;ny = 31\n    x0 = -2.0;x1 = 2.0;y0 = -2.0;y1 = 2.0\n    mandelbrot = zeros(Int64,nx, ny)\n\n    for iy=1:ny\n        y = y0 + (y1 - y0) * (iy - 1) / real(ny - 1)\n        for ix=1:nx\n            x = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)\n            mandelbrot[ix, iy] = mandel(x+im*y) \n        end  \n    end\n    \n    for iy=1:ny\n        for ix=1:nx\n            if mandelbrot[ix,iy] == maxiter\n                print(\"*\")\n            else\n                print((mandelbrot[ix,iy]+9) ÷ 10)\n            end\n        end\n        println(\"\\t\")\n    end\nend\nmandel_main()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"一つ目のFortran90コードで気をつけたポイントの他には、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"MODULEはmoduleに。モジュールの名前はJuliaでは最初の一文字を大文字にする慣例があるのでそれにならった\nUSE m_mandelはusing .M_mandelに。関数の中ではなく、外に定義する\nFortranではモジュール内で宣言した変数や関数はデフォルトでshare属性を持っておりuseですぐに使えるが、Juliaの場合に同様にしたい場合にはexportをモジュール内で使っておく。使わない場合はM_mandel.mandel(x+im*y)とアクセスすることになる","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"ということに気をつけました。","category":"page"},{"location":"chapter2/01/#Fortran2003","page":"FortranのコードをJuliaへ移植してみる","title":"Fortran2003","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"次は、同じ記事のFortran2003のコードをJuliaに移植してみます。Fortranのコードを引用すると","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"program mandel\n    implicit none\n    integer, parameter :: maxiter = 90, nx = 61, ny = 31\n    real   , parameter :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0\n    character(len = 10), parameter :: text = '|+o0O.@*#-'  \n    integer :: ix, iy, iter, mandelbrot(nx, ny) = 0, m(nx)  \n    real, allocatable :: x(:), y(:)\n    complex :: c(nx, ny), z(nx, ny) = (0.0, 0.0)\n    x = [( (x1 - x0) / (nx - 1) * (ix - 1) + x0, ix = 1, nx )]\n    y = [( (y1 - y0) / (ny - 1) * (iy - 1) + y0, iy = 1, ny )]\n    forall (ix = 1:nx, iy = 1:ny) c(ix, iy) = cmplx(x(ix), y(iy))\n    do iter = 0, maxiter\n      where (abs(z) <= 2.0) \n        z = z * z + c\n        mandelbrot = mandelbrot + 1\n      end where  \n    end do\n\n    do iy = 1, ny\n      m = (mandelbrot(:, iy) + 8) / 10  + 1\n      write(*, '(61a1)') (text(m(ix):m(ix)), ix = 1, nx)  \n    end do\n    stop\nend program mandel","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。このコードをコンパイルして実行すると、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"||||||||||||||||||||||||||||||+||||||||||||||||||||||||||||||\n||||||||||||||||||||+++++++++++++++++++++||||||||||||||||||||\n||||||||||||||||+++++++++++++++++++++++++++++||||||||||||||||\n||||||||||||+++++++++++++++++++++++++++++++++++++||||||||||||\n||||||||||+++++++++++++++++++++++++++++++++++++++++||||||||||\n||||||||+++++++++++++++++++++++++++++++++++++++++++++||||||||\n||||||+++++++++++++++++++++++++++++++++++++++++++++++++||||||\n|||||+++++++++++++++++++++++++++++++++++++++++++++++++++|||||\n||||++++++++++++++++++++++++o++++++++++++++++++++++++++++||||\n|||++++++++++++++++++++++++---o+++++++++++++++++++++++++++|||\n||+++++++++++++++++++00+ooo0-*o@*++++++++++++++++++++++++++||\n||++++++++++++++++++++-------------@+++++++++++++++++++++++||\n|+++++++++++++++++++o---------------++++++++++++++++++++++++|\n|+++++++++++o-O-0O+o----------------o+++++++++++++++++++++++|\n|++++++++o+o------------------------.+++++++++++++++++++++++|\n----------------------------------0++++++++++++++++++++++++++\n|++++++++o+o------------------------.+++++++++++++++++++++++|\n|+++++++++++o-O-0O+o----------------o+++++++++++++++++++++++|\n|+++++++++++++++++++o---------------++++++++++++++++++++++++|\n||++++++++++++++++++++-------------@+++++++++++++++++++++++||\n||+++++++++++++++++++00+ooo0-*o@@++++++++++++++++++++++++++||\n|||++++++++++++++++++++++++---o+++++++++++++++++++++++++++|||\n||||++++++++++++++++++++++++o++++++++++++++++++++++++++++||||\n|||||+++++++++++++++++++++++++++++++++++++++++++++++++++|||||\n||||||++++++++++++++++++++++++++++++++++++++++++++++++|||||||\n||||||||+++++++++++++++++++++++++++++++++++++++++++++||||||||\n||||||||||+++++++++++++++++++++++++++++++++++++++++||||||||||\n||||||||||||++++++++++++++++++++++++++++++++++++|||||||||||||\n||||||||||||||||+++++++++++++++++++++++++++++||||||||||||||||\n||||||||||||||||||||+++++++++++++++++++++||||||||||||||||||||\n||||||||||||||||||||||||||||||+||||||||||||||||||||||||||||||","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"対応するJuliaのコードは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"function mandel()\n    maxiter = 90;nx = 61; ny = 31\n    x0 = -2.0; x1 = 2.0; y0 = -2.0; y1 = 2.0\n\n    text = \"|+o0O.@*#-\"\n    z = zeros(ComplexF64,nx,ny)\n    mandelbrot = zeros(Int64,nx,ny)\n\n    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]\n    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]\n    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]\n    for iter=0:maxiter\n        for i=1:length(z)\n            if abs(z[i]) <= 2\n                z[i] = z[i]*z[i]+c[i]\n                mandelbrot[i] += 1\n            end\n        end\n    end\n\n    for iy=1:ny\n        m = (mandelbrot[:, iy] .+ 8) .÷ 10  .+ 1\n        [print(text[m[ix]:m[ix]]) for ix=1:nx]\n        println(\"\\t\")\n    end\nend\nmandel()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"です。Fortranでのwhere構文（配列の各要素に条件式を当てはめてループする構文）のJulia対応が分かりませんでしたので、仕方がないのでforループを使いました。ただし、そのまま書いても芸がありませんので、2次元配列のzなどを1次元配列として取り出す方法を使ってみました。Juliaでは2次元配列をメモリ格納順に並べた1次元のインデックスを用いて値を操作することができます。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"今回は","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"for文のリスト内包表記[ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]の使用\nFortranのforallの代わりに二重forループのリスト内包表記の使用\n配列の各要素にまとめて演算するために.を使ったブロードキャストを使用（m = (mandelbrot[:, iy] .+ 8) .÷ 10  .+ 1）","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"を行いました。","category":"page"},{"location":"chapter2/01/#Fortran2003-オブジェクト指向","page":"FortranのコードをJuliaへ移植してみる","title":"Fortran2003 オブジェクト指向","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"次は、同じ記事のオブジェクト指向で書かれたFortranコードをJuliaに移植してみます。 コードは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"module m_bmp\n    implicit none\n    type :: t_bmp_file_header\n      sequence                      ! 14bytes\n      character(len = 2) :: bfType = 'BM' !integer(2) :: bfType = transfer('BM', 0_2, 1) ! BitMap\n      integer(4) :: bfSize          ! file size in bytes\n      integer(2) :: bfReserved1 = 0 ! always 0\n      integer(2) :: bfReserved2 = 0 ! always 0\n      integer(4) :: bfOffBits\n    end type t_bmp_file_header\n    ! \n    type :: t_bmp_info_header \n      sequence\n      integer(4) :: biSize     = Z'28' ! size of bmp_info_header ; 40bytes \n      integer(4) :: biWidth\n      integer(4) :: biHeight\n      integer(2) :: biPlanes   = 1 ! always 1\n      integer(2) :: biBitCount\n      integer(4) :: biCompression = 0 !0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield\n      integer(4) :: biSizeImage\n      integer(4) :: biXPelsPerMeter = 3780 ! 96dpi\n      integer(4) :: biYPelsPerMeter = 3780 ! 96dpi \n      integer(4) :: biClrUsed      = 0\n      integer(4) :: biClrImportant = 0 \n    end type t_bmp_info_header  \n    !\n    type :: t_rgb\n      sequence\n      character :: b, g, r  ! order is b g r \n    end type t_rgb \n    !\n    type :: t_bmp(nx, ny)\n      integer, len:: nx, ny  \n      type(t_rgb) :: rgb(nx, ny)\n    contains \n      procedure :: wr => wr_bmp\n      procedure :: pr_bmp\n      generic :: write(formatted) => pr_bmp\n    end type\n  contains   \n    subroutine wr_bmp(bmp, fn)\n      class(t_bmp(*, *)), intent(in) :: bmp\n      character(len = *), intent(in) :: fn\n      type(t_bmp_file_header) :: bmp_file_header\n      type(t_bmp_info_header) :: bmp_info_header\n      bmp_file_header%bfSize      = 14 + bmp_info_header%biSize + 0 + bmp%nx * bmp%ny * 3\n      bmp_file_header%bfOffBits   = 14 + bmp_info_header%biSize\n      bmp_info_header%biWidth     = bmp%nx       ! nx shouold be a multiple of 4\n      bmp_info_header%biHeight    = bmp%ny\n      bmp_info_header%biBitCount  = 24           ! color depth 24bits\n      bmp_info_header%biSizeImage = bmp%nx * bmp%ny * 3\n      open(9, file = fn//'.bmp', form = 'binary', status = 'unknown')\n      write(9) bmp_file_header\n      write(9) bmp_info_header\n      write(9) bmp%rgb\n      close(9)\n      return\n    end subroutine wr_bmp\n! convert to t_RGB    \n    pure elemental type(t_rgb) function to_rgb(ir, ig, ib)\n      integer, intent(in) :: ir, ig, ib\n      to_rgb = t_rgb(achar(ib), achar(ig), achar(ir))\n    end function to_rgb  \n\n    subroutine pr_bmp(dtv, unit, iotype, vlist, io, iomsg)\n      class(t_bmp(*, *)), intent(in) :: dtv\n      integer, intent(in) :: unit\n      character(len = *), intent(in) :: iotype\n      integer, intent(in) :: vlist(:)\n      integer, intent(out) :: io\n      character(len = *), intent(in out) :: iomsg\n      character(len = 30) :: fmt\n      if (iotype == 'LISTDIRECTED') then\n        write(unit, *, iostat = io) 'nx =', dtv%nx, ', ny =', dtv%ny\n      end if    \n    end subroutine pr_bmp\n  end module m_bmp\n\n  module m_mandel\n    implicit none\n    integer, parameter :: maxiter = 254\n  contains\n    pure elemental integer function mandel(c)\n      complex, intent(in) :: c\n      complex :: z\n      z = (0.0, 0.0)\n      do mandel = 0, maxiter\n        z = z * z + c\n        if (abs(z) > 2.0) exit\n      end do    \n    end function mandel \n  end module m_mandel\n\n  program mandel_main\n    use m_bmp\n    use m_mandel \n    implicit none\n    integer, parameter :: nx = 640, ny = 640\n    real   , parameter :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0\n    integer :: ix, iy, iter, mandelbrot(nx, ny)\n    real    :: x(nx), y(ny)\n    complex :: c(nx, ny)\n    type(t_bmp(nx, ny)) :: bmp \n!\n    forall (ix = 1:nx) x(ix) = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)\n    forall (iy = 1:ny) y(iy) = y0 + (y1 - y0) * (iy - 1) / real(ny - 1)\n    forall (ix = 1:nx, iy = 1:ny) c(ix, iy) = cmplx(x(ix), y(iy))\n    mandelbrot = mandel(c)  \n!\n    bmp%rgb = to_rgb(255 - mandelbrot, 255 - mandelbrot, 255 - mandelbrot)\n    call bmp%wr('test')\n    print *, 'BMP size: ', bmp\n    stop \n  end program mandel_main","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"です。このコードですが、gfortranでコンパイルしようとしても失敗してしまいました。こちらによると、どうやら「Fortran2003 で導入されたパラメータ付派生型(parameterized derived type)」がgfortranがこの機能にフルに対応していないようです。ですので、このコードの実行を確認できていません。","category":"page"},{"location":"chapter2/01/#追記","page":"FortranのコードをJuliaへ移植してみる","title":"追記","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"2020年12月からIntelのFortranコンパイラであるifortが無料で使えるようになっていたようです。こちらを参照してインストールしてみたところ、無事に上のコードをコンパイルできました。なお、Macでやる時にはこちらにあるように「 -L/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib」をつける必要があるかもしれません（LIBRARY_PATHにこれを追加しておく）。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"記事によると、このコードは画像をBMP形式で出力してくれるようです。BMPのフォーマットは検索すると出てきましたので、その形式に従ってバイナリを出力する、というコードのようです。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"これのJulia版は","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"module M_bmp\n    export to_rgb,T_bmp,wr_bmp\n\n    Base.@kwdef mutable struct T_bmp_file_header\n        bfType::String = \"BM\" \n        bfSize::Int32 = 0\n        bfReserved1::Int16 = 0\n        bfReserved2::Int16 = 0\n        bfOffBits::Int32 = 0\n    end\n\n    Base.@kwdef mutable struct T_bmp_info_header \n        biSize::Int32 = 0x28\n        biWidth::Int32 = 0\n        biHeight::Int32 = 0\n        biPlanes::Int16   = 1 \n        biBitCount::Int16 = 0\n        biCompression::Int32 = 0 #0:nocompression,1:8bitRLE,2:4bitRLE,3:bitfield\n        biSizeImage::Int32 = 0\n        biXPelsPerMeter::Int32 = 3780 # 96dpi\n        biYPelsPerMeter::Int32 = 3780 # 96dpi \n        biClrUsed::Int32      = 0\n        biClrImportant::Int32 = 0 \n\n    end\n\n    mutable struct T_rgb\n        b::UInt8\n        g::UInt8\n        r::UInt8\n    end\n\n    Base.@kwdef mutable struct T_bmp{nx,ny}\n        rgb::Array{T_rgb,2} = Array{T_rgb,2}(undef,nx,ny)\n    end\n\n    function Base.write(fp::IO,data::T_bmp_file_header)\n        write(fp,data.bfType)\n        write(fp,data.bfSize)\n        write(fp,data.bfReserved1)\n        write(fp,data.bfReserved2)\n        write(fp,data.bfOffBits)\n    end\n\n    function Base.write(fp::IO,data::T_bmp_info_header)\n        write(fp,data.biSize)\n        write(fp,data.biWidth)\n        write(fp,data.biHeight)\n        write(fp,data.biPlanes)\n        write(fp,data.biBitCount)\n        write(fp,data.biCompression)\n        write(fp,data.biSizeImage)\n        write(fp,data.biXPelsPerMeter)\n        write(fp,data.biYPelsPerMeter)\n        write(fp,data.biClrUsed)\n        write(fp,data.biClrImportant)\n    end\n\n    function Base.write(fp::IO,data::T_rgb)\n        write(fp,data.b)\n        write(fp,data.g)\n        write(fp,data.r)\n    end\n\n    function Base.write(fp::IO,data::T_bmp{nx,ny}) where {nx,ny}\n        for iy=1:ny\n            for ix=1:nx\n                #println(data.rgb[ix,iy])\n                write(fp,data.rgb[ix,iy])\n            end\n        end\n    end\n\n    function wr_bmp(bmp::T_bmp{nx,ny}, fn) where {nx,ny}\n        bmp_info_header = T_bmp_info_header()\n        bmp_file_header = T_bmp_file_header()\n        bmp_file_header.bfSize      = 14 + bmp_info_header.biSize + 0 + nx * ny * 3\n        bmp_file_header.bfOffBits   = 14 + bmp_info_header.biSize\n        bmp_info_header.biWidth     = nx       # nx shouold be a multiple of 4\n        bmp_info_header.biHeight    = ny\n        bmp_info_header.biBitCount  = 24           # color depth 24bits\n        bmp_info_header.biSizeImage = nx * ny * 3\n        fp = open(fn*\".bmp\",\"w\")\n        write(fp,bmp_file_header)\n        write(fp,bmp_info_header)\n        write(fp,bmp)\n    end\n\n    function to_rgb(ir,ig,ib)\n        return T_rgb(htol(ir),htol(ig),htol(ib))\n    end\nend\n\nmodule M_mandel\n    const maxiter = 254\n    export mandel,maxiter\n\n    function mandel(c)\n        z = 0im\n        count = maxiter\n        for i=0:maxiter\n            z = z * z + c\n            if abs(z) > 2\n                count = i\n                break\n            end\n        end\n        return count\n    end\nend\n\n\nusing .M_bmp\nusing .M_mandel\n\nfunction mandel_main()\n    nx = 640;ny = 640\n    x0 = -2.0;x1 = 2.0; y0 = -2.0; y1 = 2.0\n    bmp = T_bmp{nx,ny}()\n\n    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]\n    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]\n    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]\n    mandelbrot = mandel.(c)\n\n    bmp.rgb = to_rgb.(255 .- mandelbrot,255 .- mandelbrot,255 .- mandelbrot)\n    wr_bmp(bmp,\"test\")\n    println(\"BMP size:  $nx $ny\")\nend\n\nmandel_main()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。 実行した結果は得られる画像は","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"(Image: fig1)","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"ポイントは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Fortran2003のオブジェクト指向によるクラスはJuliaではmutable structに。また、クラスのメソッドはJuliaでは多重ディスパッチで定義。\nFortranでは定義した構造体をそのままバイナリで書き出せたが、Juliaでの独自型は自分で書き出しを指定してやる必要があるため、標準のwriteを多重ディスパッチで機能拡張\nBMP形式の定義によるとt_rgbクラスに入れるべきは符号なし整数なので、JuliaではUInt8型（符号なし8ビット整数）に変更\nmutable structでデフォルトの値を入れるためにBase.@kwdefを使用\nFortranでのパラメータ付派生型と同等の機能をJuliaではパラメトリック型で実装（mutable struct T_bmp{nx,ny}）","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"です。オブジェクト指向なコードもすんなりJuliaに移植できました。","category":"page"},{"location":"chapter2/01/#パッケージの利用","page":"FortranのコードをJuliaへ移植してみる","title":"パッケージの利用","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"上で書いたJuliaのコードはFortranでBMP形式を扱うように直接バイナリを操作したものでした。Juliaの場合、自前で書かなくても関連するパッケージがあり、簡単に画像データを扱えます。ここではImagesというパッケージを使います。これをインストールするには、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"julia -e 'using Pkg;Pkg.add(\"Images\")'","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"としてください。 これを使うと、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"module M_mandel\n    const maxiter = 254\n    export mandel,maxiter\n\n    function mandel(c)\n        z = 0im\n        count = maxiter\n        for i=0:maxiter\n            z = z * z + c\n            if abs(z) > 2\n                count = i\n                break\n            end\n        end\n        return count\n    end\nend\n\nusing .M_mandel\nusing Images\n\nfunction mandel_main()\n    nx = 640;ny = 640\n    x0 = -2.0;x1 = 2.0; y0 = -2.0; y1 = 2.0\n\n    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]\n    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]\n    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]\n    mandelbrot = mandel.(c)\n    img = (255 .- mandelbrot)/255\n    save(\"test2.bmp\",img')\n    save(\"test2.png\",img')\n\n    println(\"BMP size:  $nx $ny\")\nend\nmandel_main()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"とすれば、BMP形式とPNG形式のグレースケールの画像を出力できます。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"ここでの追加のポイントとしては","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"グレースケール画像は0から1の範囲なので、255で割っている。\n行列を可視化するような形に出力されるため、デフォルトではxが下方向、yが右方向になっている。これを変更するために、imgを'で転置した。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"です。Fortranと異なりJuliaはモダンな言語ですから、画像や動画の扱いが容易です。","category":"page"},{"location":"chapter2/01/#万有引力に従う天体の運動","page":"FortranのコードをJuliaへ移植してみる","title":"万有引力に従う天体の運動","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"こちらのサイトでは、万有引力に従う粒子の運動の解説とFortranコードの説明があります。ここにあるFortranコードをJuliaに移植してみることにします。","category":"page"},{"location":"chapter2/01/#基本方程式","page":"FortranのコードをJuliaへ移植してみる","title":"基本方程式","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"二つの物体の間には物体の質量に比例しその距離の二乗に反比例する引力（万有引力）","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"F = - G fracMmr^2","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"が働きます。この力があるため、太陽の周りを地球などが回っているわけです。これをコードで示すことにします。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"無次元化された運動方程式を","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"dotx = u dotu = - fracxbm r^3","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"doty = v dotv = - fracybm r^3","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"として、天体の動きを追いかけることとします。なお、簡単のためz方向には天体を固定し動かないこととしました。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"方程式の時間発展にはいくつかの方法があります。微分方程式が","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"dotx = u dotu = Phi(x)","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"と書ける時の時間発展法について述べます。方程式のエネルギーを保存させるためにはシンプレクティック解法と呼ばれる手法を用いる必要がありまして、ここではLeap-frog法とVelocity Verlet法を紹介します。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Leap-frog法","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"u(t + Delta t2) = u(t - Delta2) + Phi(x) Delta t","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"x(t + Delta t) = x(t) + u(t + Delta t2) Delta t","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"という形になりまして、Delta2だけ速度uを動かしてからxを更新します。tでの速度は","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"u(t) = (u(t - Delta2) + u(t + Delta2))2","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"と計算できます。最初のステップではDelta(-Delta t2)での値が必要ですので、これは方程式を逆に解いて","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Delta(-Delta t2) = u(0) - Phi(x) Delta 2","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"とします。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Velocity Verlet法","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Velocity Verlet法の場合には、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"x(t + Delta t) = x(t) + u(t) Delta t + Phi(x) frac(Delta t)^22","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"u(t + Delta t) = u(t) + (Phi(x(t)) + Phi(x(t+Delta t))) fracDelta t2","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"とします。","category":"page"},{"location":"chapter2/01/#Leap-frog法による二体問題","page":"FortranのコードをJuliaへ移植してみる","title":"Leap-frog法による二体問題","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Fortranで書かれたソースコードはこちらにあります。ここにあるコードをJuliaに移植してみました。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"コードは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"\nmodule Subfunc\n    export fx,fu,fy,fv\n    function fx(u,v)\n        return u\n    end\n\n    function fu(x,y)\n        r = sqrt(x^2+y^2)\n        xx = -x / r^3\n        return xx\n    end\n\n    function fy(u,v)\n        return v\n    end\n\n    function fv(x,y)\n        r = sqrt(x^2+y^2)\n        xx = -y / r^3\n        return xx\n    end\n\nend\nusing .Subfunc\n\nfunction celestial()\n    n=10^8\n    noutmax = 10000\n    x = 1.0\n    y = 0.0\n    u = 0.0\n    v = 1.0\n    t = 0.0\n\n    uold = 0.0\n    vold = 0.0\n    E0 = 0.0\n    u_b = 0.0\n    v_b = 0.0\n\n    tmax = 10.0e5\n    delta_t = (tmax-t)/n\n    fp = open(\"outputLF_julia.dat\",\"w\")\n    println(fp,\"t_lf, x_lf, y_lf, E_lf, dE_lf\")\n    if n > noutmax\n        dout = n ÷  noutmax\n    else\n        dout = 1\n    end\n\n\n    for i=1:n-1\n        if i == 1\n            E0 = 0.5*(u^2+v^2) - 1.0/sqrt(x^2+y^2)\n            u_b = u - 0.5*fu(x,y)*delta_t\n            v_b = v - 0.5*fv(x,y)*delta_t\n            uold = u\n            vold = v\n        end\n\n        u = uold\n        v = vold\n\n        E = 0.5*(u^2+v^2) - 1.0/sqrt(x^2+y^2)\n        dE = abs((E - E0)/E0)\n\n        if (i-1) % dout == 0\n            println(fp,\"\\t\",t,\"\\t,\",x,\"\\t,\",y,\"\\t,\",E,\"\\t,\",dE)\n        end\n           \n        \n        u_a = u_b + fu(x,y)*delta_t\n        v_a = v_b + fv(x,y)*delta_t\n        x = x + u_a*delta_t\n        y = y + v_a*delta_t\n        uold = (u_a + u_b)/2.0\n        vold = (v_a + v_b)/2.0\n        u_b = u_a\n        v_b = v_a\n        \n        t = t + delta_t\n    \n    end\n\n\nend\n@time celestial()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。リンク先のFortranコードを忠実に変換した形になっているかと思います。計算速度もほぼ同じになっているのが確認できると思います。","category":"page"},{"location":"chapter2/01/#Velocity-Verlet法によるN体問題","page":"FortranのコードをJuliaへ移植してみる","title":"Velocity Verlet法によるN体問題","text":"","category":"section"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"次に、N体問題を解いてみます。こちらのページを参考にしています。 複数の粒子がある場合は万有引力はそれぞれの粒子から受けますので、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"F(bm x_i) = - G sum_j fracm_i m_jbm r_i - bm r_j^2","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"それでは、太陽、地球、金星、火星、そして月の5つの天体が存在する場合の軌道を調べてみましょう。そのFortran版のコードはこちらにあります。 このコードを手元のPCでコンパイルし、実行しますと、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":" current step:      100000 /total step:     1000000\n current step:      200000 /total step:     1000000\n current step:      300000 /total step:     1000000\n current step:      400000 /total step:     1000000\n current step:      500000 /total step:     1000000\n current step:      600000 /total step:     1000000\n current step:      700000 /total step:     1000000\n current step:      800000 /total step:     1000000\n current step:      900000 /total step:     1000000\n Time step:   6.3717374890228697E-005\n Average error of energy update:   1.0575727271732502E-021\n CPU time:  0.38528799999999996  ","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"という結果が得られました。約0.4秒で実行が終わっていますね。このコードを素朴にJuliaのコードにしたものが","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"module Globals\n    export G,ndim,nbody\n    const G = 6.67384e-11\n    const ndim = 2\n    const nbody = 5\nend\n\nmodule Mod_Var_trajectory\n    using ..Globals\n    export Var_trajectory\n    Base.@kwdef struct Var_trajectory\n        coord::Array{Float64,2} = zeros(Float64,ndim,nbody)\n        veloc::Array{Float64,2} = zeros(Float64,ndim,nbody)\n    end\nend\n\nmodule Mod_Param_planet\n    using ..Globals\n    export Param_planet\n    Base.@kwdef struct Param_planet\n        mass::Array{Float64,1} = zeros(Float64,nbody)\n    end\nend\n\nmodule Cal_ene\n    using ..Globals\n    using ..Mod_Param_planet\n    export cal_kin,cal_pot\n    \n\n    function cal_kin(param::Param_planet,v)\n        e = 0.0\n        for i=1:nbody\n            v2 = 0.0\n            for j=1:ndim\n                v2 += v[j,i]^2\n            end \n            e += 0.5*param.mass[i]*v2\n        end\n        return e\n    end\n\n    function cal_pot(param::Param_planet,c)\n        e = 0.0\n        rij = zeros(Float64,ndim)\n\n        for i=1:nbody-1\n            for j=i+1:nbody\n                rij[:] = c[:,j]-c[:,i]\n                rij2 = 0.0\n                for k=1:ndim\n                    rij2 += rij[k]^2\n                end \n                rij_abs = sqrt(rij2)\n                e +=  param.mass[i]*param.mass[j]/rij_abs\n            end \n        end \n        return e\n    end\nend\n\nmodule Cal_force\n    using ..Globals\n    using ..Mod_Param_planet\n    export force!\n\n    function force!(param::Param_planet,c,a)\n        f = zeros(Float64,ndim,nbody)\n        rij = zeros(Float64,ndim)\n        fij = zeros(Float64,ndim)\n\n        for i = 1:nbody-1\n            for j = i+1:nbody\n                rij[:] = c[:,j]-c[:,i]\n                rij2 = 0.0\n                for k=1:ndim\n                    rij2 +=  rij[k]^2\n                end \n                rij_abs = sqrt(rij2)\n                inv_rij_abs = 1.0/rij_abs\n                ftmp = param.mass[i]*param.mass[j]*(inv_rij_abs^3)\n                @. fij = ftmp*rij\n                f[:,i] = f[:,i] + fij[:]\n                f[:,j] = f[:,j] - fij[:]\n            end \n        end \n\n        for i = 1:nbody\n            a[:,i] = f[:,i] / param.mass[i]\n        end \n    end\nend\n\nusing .Globals\nusing .Mod_Var_trajectory\nusing .Mod_Param_planet\nusing .Cal_ene\nusing .Cal_force\n\nfunction celestial()\n    n=10^6\n    noutmax=10000\n    nlive=10\n\n    accel = zeros(Float64,ndim,nbody)\n\n    #!----- mass\n    param_planet = Param_planet()\n    mass = param_planet.mass\n    mass[1] = 1.989e30          # mass of sun[kg]\n    mass[2] = 5.972e24          # mass of earth[kg]\n    mass[3] = 4.869e24          # venus\n    mass[4] = 6.419e23          # mars\n    mass[5] = 7.348e22          # mass of moon[kg]\n    \n\n    var_trajectory = Var_trajectory()\n    coord = var_trajectory.coord\n    #!----- initial conditions\n    coord[1,1] = 0.0\n    coord[2,1] = 0.0\n    coord[1,2] = 1.496e11       #!average radius of revolution of earth[m]\n    coord[2,2] = 0.0\n    coord[1,3] = 1.082e11\n    coord[2,3]= 0.0\n    coord[1,4] = 2.279e11\n    coord[2,4] = 0.0\n    coord[1,5] = 3.844e8        #!average radius of revolution of moon[m]\n    coord[1,5] += coord[1,2] \n    coord[2,5] = 0.0\n\n    veloc = var_trajectory.veloc\n    veloc[1,1] = 0.0\n    veloc[2,1] = 0.0\n    veloc[1,2] = 0.0\n    veloc[2,2] = 2.978e4        #!average velocity of earth[m/s]\n    veloc[1,3] = 0.0\n    veloc[2,3] = 3.502e4\n    veloc[1,4] = 0.0\n    veloc[2,4] = 2.413e4\n    veloc[1,5] = 0.0\n    veloc[2,5] = 1.022e3        #!average velocity of moon[m/s]\n    veloc[2,5] += veloc[2,2] \n    \n\n    #!----- time\n    t = 0.0\n    tmax = 3.2e8              #!365day*24hour*60min*60sec = 31536000sec = 3.2d7\n    \n    #!----- normalizse\n    cnor = sqrt((coord[1,2]-coord[1,1])^2 + (coord[2,2]-coord[2,1])^2)\n    mnor = mass[1]\n    tnor = sqrt(cnor^3/(G*mnor))\n    vnor = cnor/tnor\n    \n    @. var_trajectory.coord = coord/cnor\n    @. var_trajectory.veloc = veloc/vnor\n    @. param_planet.mass = mass/mnor\n    t = t/tnor\n    tmax = tmax/tnor\n\n\n    dt = (tmax-t)/n\n    dt2 = 0.5*dt\n\n    sum_dE  = 0.0\n    E0 = 0.0\n    Eold = 0.0\n\n    fp = open(\"outputNvV_julia_vv.dat\",\"w\")\n    println(fp,\"t_NvV, E_NvV, dE_NvV, x1_NvV, y1_NvV, x2_NvV, y2_NvV, \n      x3_NvV, y3_NvV, x4_NvV, y4_NvV, x5_NvV, y5_NvV\")\n\n    nliveout = n ÷  nlive\n    if n > noutmax\n        dout = n ÷ noutmax\n    else\n        dout = 1\n    end\n\n\n    for i = 1:n-1\n\n        if i % nliveout == 0\n            println(\"current step: $i,/total step: $n\")\n        end\n    \n        if i == 1\n            Ev = cal_kin(param_planet,veloc)\n            Ep = cal_pot(param_planet,coord)\n            E0 = Ev-Ep\n            Eold = E0   \n        end\n\n        Ev = cal_kin(param_planet,veloc)\n        Ep = cal_pot(param_planet,coord)\n        E = Ev-Ep\n        dE = abs((E - E0)/E0)\n        sum_dE += abs(E-Eold)\n\n        if (i-1) % dout == 0\n            println(fp,\n            t,\"\\t\",',',E,\"\\t\",',',dE,\"\\t\",',',coord[1,1],\"\\t\",',',coord[2,1],\"\\t\",',',coord[1,2],\"\\t\",',',coord[2,2],\"\\t\",',',coord[1,3]\n            ,\"\\t\",',',coord[2,3],\"\\t\",',',coord[1,4],\"\\t\",',',coord[2,4],\"\\t\",',',coord[1,5],\"\\t\",',',coord[2,5]\n            )\n        end\n\n        #println(coord)\n        if i == 1\n            force!(param_planet,coord,accel)\n        end\n        #println(accel)\n        #exit()\n\n        @. veloc += dt2*accel\n        @. coord += dt*veloc\n        force!(param_planet,coord,accel)\n        @. veloc += dt2*accel\n\n        t = t + dt\n        Eold = E\n    end\n    \n    close(fp)\n\n    println(\"Time step: \",dt)\n    println(\"Average error of energy update: \",sum_dE/n)\nend\n@time celestial()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"こちらです。なるべく元のコードと同じ形になるように移植しました。 このコードのポイントは","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"Fortranでのmoduleを用いた「グローバル変数」のような扱い（ここではmass等）を、全て独自型としてまとめて引数に入れるようにした\n1.を行った結果var_trajectory.massのように変数名が長くなってしまったので、mass = var_trajectory.massのように参照用の変数を導入した。このようにするとmassの中身を書き換えたときにvar_trajectory.massも書き換わる。veloc = var_trajectory.velocやcoord = var_trajectory.coordも同様\n配列の要素にまとめて入れるために@.マクロを使用した。@. var_trajectory.coord = coord/cnorなどで使用","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。このコードですが、同じPCで実行すると、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"current step: 100000,/total step: 1000000\ncurrent step: 200000,/total step: 1000000\ncurrent step: 300000,/total step: 1000000\ncurrent step: 400000,/total step: 1000000\ncurrent step: 500000,/total step: 1000000\ncurrent step: 600000,/total step: 1000000\ncurrent step: 700000,/total step: 1000000\ncurrent step: 800000,/total step: 1000000\ncurrent step: 900000,/total step: 1000000\nTime step: 6.37173748902287e-5\nAverage error of energy update: 1.0575727271732502e-21\n  5.327849 seconds (134.88 M allocations: 12.121 GiB, 4.46% gc time, 3.86% compilation time)","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となり、\"Average error of energy update\"は倍精度の範囲で結果が一致していることがわかります。ただし、計算時間が5.3秒もかかってしまっていて遅いです。","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"これを高速化する方法は簡単です。メモリーアロケーションが134.88 M allocationsとなっていますから、これは不必要なメモリ確保が沢山生じていることを意味しています。どこにそれがあるかをみてみますと、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"rij[:] = c[:,j]-c[:,i]","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"などです。右辺のc[:,j]は行列でいうところの1列だけを取り出しています。Juliaでは:を右辺で使って配列の一部範囲を取り出す場合、配列のコピーが発生してしまいます。これを避けるには@viewというマクロを使うか、素朴に","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"for k=1:length(rij) \n  rij[k] = c[k,j]-c[k,i]\nend","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"のようにループするかです。ループの方がシンプルなので、複数の該当箇所をループに置き換えてみると、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"module Globals\n    export G,ndim,nbody\n    const G = 6.67384e-11\n    const ndim = 2\n    const nbody = 5\nend\n\nmodule Mod_Var_trajectory\n    using ..Globals\n    export Var_trajectory\n    Base.@kwdef struct Var_trajectory\n        coord::Array{Float64,2} = zeros(Float64,ndim,nbody)\n        veloc::Array{Float64,2} = zeros(Float64,ndim,nbody)\n    end\nend\n\nmodule Mod_Param_planet\n    using ..Globals\n    export Param_planet\n    Base.@kwdef struct Param_planet\n        mass::Array{Float64,1} = zeros(Float64,nbody)\n    end\nend\n\nmodule Cal_ene\n    using ..Globals\n    using ..Mod_Param_planet\n    export cal_kin,cal_pot\n    \n\n    function cal_kin(param::Param_planet,v)\n        e = 0.0\n        for i=1:nbody\n            v2 = 0.0\n            for j=1:ndim\n                v2 += v[j,i]^2\n            end \n            e += 0.5*param.mass[i]*v2\n        end\n        return e\n    end\n\n    function cal_pot(param::Param_planet,c)\n        e = 0.0\n        rij = zeros(Float64,ndim)\n\n        for i=1:nbody-1\n            for j=i+1:nbody\n                for k=1:ndim\n                    rij[k] = c[k,j]-c[k,i]\n                end\n                rij2 = 0.0\n                for k=1:ndim\n                    rij2 += rij[k]^2\n                end \n                rij_abs = sqrt(rij2)\n                e +=  param.mass[i]*param.mass[j]/rij_abs\n            end \n        end \n        return e\n    end\nend\n\nmodule Cal_force\n    using ..Globals\n    using ..Mod_Param_planet\n    export force!\n\n    function force!(param::Param_planet,c,a)\n        f = zeros(Float64,ndim,nbody)\n        rij = zeros(Float64,ndim)\n        fij = zeros(Float64,ndim)\n\n        for i = 1:nbody-1\n            for j = i+1:nbody\n                for k=1:ndim\n                    rij[k] = c[k,j]-c[k,i]\n                end\n                rij2 = 0.0\n                for k=1:ndim\n                    rij2 +=  rij[k]^2\n                end \n                rij_abs = sqrt(rij2)\n                inv_rij_abs = 1.0/rij_abs\n                ftmp = param.mass[i]*param.mass[j]*(inv_rij_abs^3)\n                @. fij = ftmp*rij\n                for k=1:ndim\n                    f[k,i] = f[k,i] + fij[k]\n                    f[k,j] = f[k,j] - fij[k]\n                end\n            end \n        end \n\n        for i = 1:nbody\n            for k=1:ndim\n                a[k,i] = f[k,i] / param.mass[i]\n            end\n        end \n    end\nend\n\nusing .Globals\nusing .Mod_Var_trajectory\nusing .Mod_Param_planet\nusing .Cal_ene\nusing .Cal_force\n\nfunction celestial()\n    n=10^6\n    noutmax=10000\n    nlive=10\n\n    accel = zeros(Float64,ndim,nbody)\n\n    #!----- mass\n    param_planet = Param_planet()\n    mass = param_planet.mass\n    mass[1] = 1.989e30          # mass of sun[kg]\n    mass[2] = 5.972e24          # mass of earth[kg]\n    mass[3] = 4.869e24          # venus\n    mass[4] = 6.419e23          # mars\n    mass[5] = 7.348e22          # mass of moon[kg]\n    \n\n    var_trajectory = Var_trajectory()\n    coord = var_trajectory.coord\n    #!----- initial conditions\n    coord[1,1] = 0.0\n    coord[2,1] = 0.0\n    coord[1,2] = 1.496e11       #!average radius of revolution of earth[m]\n    coord[2,2] = 0.0\n    coord[1,3] = 1.082e11\n    coord[2,3]= 0.0\n    coord[1,4] = 2.279e11\n    coord[2,4] = 0.0\n    coord[1,5] = 3.844e8        #!average radius of revolution of moon[m]\n    coord[1,5] += coord[1,2] \n    coord[2,5] = 0.0\n\n    veloc = var_trajectory.veloc\n    veloc[1,1] = 0.0\n    veloc[2,1] = 0.0\n    veloc[1,2] = 0.0\n    veloc[2,2] = 2.978e4        #!average velocity of earth[m/s]\n    veloc[1,3] = 0.0\n    veloc[2,3] = 3.502e4\n    veloc[1,4] = 0.0\n    veloc[2,4] = 2.413e4\n    veloc[1,5] = 0.0\n    veloc[2,5] = 1.022e3        #!average velocity of moon[m/s]\n    veloc[2,5] += veloc[2,2] \n    \n\n    #!----- time\n    t = 0.0\n    tmax = 3.2e8              #!365day*24hour*60min*60sec = 31536000sec = 3.2d7\n    \n    #!----- normalizse\n    cnor = sqrt((coord[1,2]-coord[1,1])^2 + (coord[2,2]-coord[2,1])^2)\n    mnor = mass[1]\n    tnor = sqrt(cnor^3/(G*mnor))\n    vnor = cnor/tnor\n    \n    @. var_trajectory.coord = coord/cnor\n    @. var_trajectory.veloc = veloc/vnor\n    @. param_planet.mass = mass/mnor\n    t = t/tnor\n    tmax = tmax/tnor\n\n\n    dt = (tmax-t)/n\n    dt2 = 0.5*dt\n\n    sum_dE  = 0.0\n    E0 = 0.0\n    Eold = 0.0\n\n    fp = open(\"outputNvV_julia_vv.dat\",\"w\")\n    println(fp,\"t_NvV, E_NvV, dE_NvV, x1_NvV, y1_NvV, x2_NvV, y2_NvV, \n      x3_NvV, y3_NvV, x4_NvV, y4_NvV, x5_NvV, y5_NvV\")\n\n    nliveout = n ÷  nlive\n    if n > noutmax\n        dout = n ÷ noutmax\n    else\n        dout = 1\n    end\n\n\n    for i = 1:n-1\n\n        if i % nliveout == 0\n            println(\"current step: $i,/total step: $n\")\n        end\n    \n        if i == 1\n            Ev = cal_kin(param_planet,veloc)\n            Ep = cal_pot(param_planet,coord)\n            E0 = Ev-Ep\n            Eold = E0   \n        end\n\n        Ev = cal_kin(param_planet,veloc)\n        Ep = cal_pot(param_planet,coord)\n        E = Ev-Ep\n        dE = abs((E - E0)/E0)\n        sum_dE += abs(E-Eold)\n\n        if (i-1) % dout == 0\n            println(fp,\n            t,\"\\t\",',',E,\"\\t\",',',dE,\"\\t\",',',coord[1,1],\"\\t\",',',coord[2,1],\"\\t\",',',coord[1,2],\"\\t\",',',coord[2,2],\"\\t\",',',coord[1,3]\n            ,\"\\t\",',',coord[2,3],\"\\t\",',',coord[1,4],\"\\t\",',',coord[2,4],\"\\t\",',',coord[1,5],\"\\t\",',',coord[2,5]\n            )\n        end\n\n        #println(coord)\n        if i == 1\n            force!(param_planet,coord,accel)\n        end\n        #println(accel)\n        #exit()\n\n        @. veloc += dt2*accel\n        @. coord += dt*veloc\n        force!(param_planet,coord,accel)\n        @. veloc += dt2*accel\n\n        t = t + dt\n        Eold = E\n    end\n    \n    close(fp)\n\n    println(\"Time step: \",dt)\n    println(\"Average error of energy update: \",sum_dE/n)\nend\n@time celestial()","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となります。 この実行結果は、","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"current step: 100000,/total step: 1000000\ncurrent step: 200000,/total step: 1000000\ncurrent step: 300000,/total step: 1000000\ncurrent step: 400000,/total step: 1000000\ncurrent step: 500000,/total step: 1000000\ncurrent step: 600000,/total step: 1000000\ncurrent step: 700000,/total step: 1000000\ncurrent step: 800000,/total step: 1000000\ncurrent step: 900000,/total step: 1000000\nTime step: 6.37173748902287e-5\nAverage error of energy update: 1.0575727271732502e-21\n  0.700156 seconds (4.88 M allocations: 509.987 MiB, 12.72% gc time, 30.04% compilation time)","category":"page"},{"location":"chapter2/01/","page":"FortranのコードをJuliaへ移植してみる","title":"FortranのコードをJuliaへ移植してみる","text":"となり、計算速度がFortranとほぼ同じオーダーとなります。ただし、まだメモリーアロケーションが多いので、改善する余地はあると思います。","category":"page"},{"location":"#Fortranから始めるJulia","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"","category":"section"},{"location":"#はじめに","page":"Fortranから始めるJulia","title":"はじめに","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"このウェブサイトは、Fortranで数値計算を行なったことがある人が、Juliaについて勉強するためのサイトです。そのため、Fortranについてはある程度の知識がありコードを書いたことがある人を対象として、Juliaについて解説したいと思います。","category":"page"},{"location":"#目次","page":"Fortranから始めるJulia","title":"目次","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"    Pages = [\n          \"index.md\"\n          \"chapter1/01.md\"\n          \"chapter1/02.md\"\n          \"chapter2/01.md\"\n          \"chapter2/02.md\"\n    ]\n    Depth = 3","category":"page"},{"location":"#Juliaはどんなプログラミング言語か","page":"Fortranから始めるJulia","title":"Juliaはどんなプログラミング言語か","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Juliaという言語がどのような考えで開発されたか、についてはなぜ僕らはJuliaを作ったかを見てみてください。非常に新しい言語で、数値計算がしやすい言語として開発されています。","category":"page"},{"location":"#Fortran使いがJuliaを学ぶメリット","page":"Fortranから始めるJulia","title":"Fortran使いがJuliaを学ぶメリット","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Fortran使いがJuliaを学ぶメリットについて述べます。 まず、大前提として、本当に本気の大規模な並列計算を伴う数値計算を行う場合には、現状ではFortranを使った方が高速だと思います。多くのスーパーコンピュータではそのスパコンに最適化されたコンパイラが提供されており、それらのコンパイラを用いて適切にチューニングされたFortranのコードは最高速度を達成すると思います。そして、計算期間が数ヶ月以上に渡るような計算の場合には、数パーセントの高速化が非常に重要になってきますが、そのような場合にはJuliaよりFortranの方が向いていると思います。 また、ちゃんと動いている既存の大きめなFortranコードをJuliaで書き換える必要はないと思います。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"それでは、Juliaにはどのようなメリットがあるでしょうか。以下の点がFortran使いにとって重要だと思います。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"実行前にコンパイルが必要ない。コンパイルに四苦八苦することがなくなる\n他の人が作ったライブラリが豊富にあり、かつ導入が簡単\n最新のモダンなコーディング技術を使えるため、書きやすくメンテナンスのしやすいコードが書ける\n古（いにしえ）のFORTRANコードから決別できる（かもしれない）\nFortranと文法が似ている：配列の添字の始まりが1から(Pythonは0から)、配列のメモリ格納順が列ベース、等、Fortranと似ている","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"それぞれの項目について説明していきます。","category":"page"},{"location":"#.-実行前にコンパイルが必要ない","page":"Fortranから始めるJulia","title":"1. 実行前にコンパイルが必要ない","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"FortranではコードをIntel Fortranコンパイラやgfortranでコンパイルし、実行ファイルを作って実行します。もしLAPACKやBLASなどのライブラリを使いたい場合には、コンパイル時にリンクを行います。複数のファイルからなるソースコードであれば、makefileを用いてコンパイルすることもあるでしょう。 Juliaではこのようなコンパイル作業は必要ありません。Juliaではコードを実行する直前に型推論と最適化を行ない、その後にコードを実行します。ですので、","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"julia hoge.jl","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"のような形でソースコードをそのまま実行することができます。 自分で書いたコードであればコンパイルはそれほど問題になりませんが、例えば他の人が書いたコードを改造して使いたい場合、コンパイル方法をどのようにすればよいかは計算機環境によって異なるために、コンパイル自体が難しい場合があります。Juliaではコンパイルという作業がありませんので、他の人が書いたコードをそのまますぐに実行することができます。","category":"page"},{"location":"#.-他の人が作ったライブラリが豊富にあり、かつ導入が簡単","page":"Fortranから始めるJulia","title":"2. 他の人が作ったライブラリが豊富にあり、かつ導入が簡単","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Fortranでは他の人が作ったライブラリを自分のコードに使う場合は、「ソースコードをそのまま使う」か「リンクが可能なライブラリとなっているものをコンパイル時にリンクする」という方法があります。どちらの方法であっても、複数のライブラリを自分のコードにリンクしてコンパイルして実行ファイルを作る、というのはなかなか難しいです。さらに、他の人が作ったライブラリがそもそも自分の計算機環境で動くのか、コンパイルが可能なのか、ということについても気を使う必要があります。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"そして、Fortranで書かれたコードというのはウェブ上ではあまり多くありません。よくあるのは、研究室で代々使っているコードや、論文の著者のウェブサイトからダウンロードしたコードや、直接やりとりをしてもらったコードだと思います。あるいは、有償あるいはオープンソースで書かれた20年近く使われ続けている巨大プロジェクトのコードだと思います。Fortranは研究室単位やプロジェクト単位で使われていることが多いため、「自由に使えるパッケージ」という概念がほとんどありません（最近はFortranでもパッケージ管理システムを作ろうという試みがこちらにあるようです）。そのため、必要な機能は自分で実装するか詳しい人にコードのありかを聞くことになります。例えば、非線形な関数f(x)の最小値となるxを求める場合、どうしますか？　詳しい方であれば、Intel Math Kernel Library (MKL)に非線形最小二乗問題を解くためのルーチンが含まれていることを知っていると思います。しかし、その存在をどうやって知ればよいでしょうか？　あるいは、2変数関数f(xy)のあるデータ点での値を複数持っているときにスプライン補間でデータを補間したい場合、どうすればいいでしょうか？　Fortranにはこの目的のためのDIERCKXというコードがあるという情報に辿り着けるでしょうか？　そして、どのように使うかわかるでしょうか？","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Juliaであれば、非線形関数の最小化のパッケージとしてOptimというパッケージがあり、スプライン補間用パッケージにDierckxがあり（実はDIERCKXのラッパーパッケージ）、どちらも簡単に使うことができます。","category":"page"},{"location":"#.-最新のモダンなコーディング技術を使えるため、書きやすくメンテナンスのしやすいコードが書ける","page":"Fortranから始めるJulia","title":"3. 最新のモダンなコーディング技術を使えるため、書きやすくメンテナンスのしやすいコードが書ける","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Fortranは歴史が長く、古いコードであってもコンパイルが可能で実行が可能であるということが大きな利点にひとつになっていると思います。科学技術分野における数値計算であれば物理現象自体が変わることはそうそうありませんから、非常に良いパフォーマンスを発揮する古いコードも使う価値があります。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"一方で、それらのコードを改造して新しい問題に対応させようとすると、よほどのFORTRAN/Fortran経験者でなければ困難になります。そして、FORTRANをいじれる人間はFORTRANをいじったことがある人間だけですから、現代でわざわざFORTRANをいじる新規参入者は少なく、FORTRAN人口は減っていってしまうでしょう。それでも巨大なプロジェクトのコードであれば開発者を確保することができるかも知れませんが、研究室単位、あるいは数人のグループによって開発されたコードの場合、読むのが困難でしょう。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"例えば、FORTRAN77時代に変数を複数の箇所で使う場合にはcommon文というものが使われていました。Fortran 90以降においてはcommon文を使うのではなくmoduleを使うことが推奨されるようになりました。しかし、module内に定義された変数の値がどのタイミングでどの関数によって変更されるかは注意深くコードを読んでいかないとわかりません。Fortranしか書いたことがない方にとってはこれは当然かもしれませんが、現代ではこのような「グローバル変数」を使うコーディングは読みにくいコードとして知られています。FortranでもFortran 2008以降のオブジェクト指向のコーディングスタイルを用いればモダンな書き方が可能ですが、現状多くのFortran使用者はオブジェクト指向Fortranを使っていません（英語及び日本語でweb検索した際の情報の少なさがそれを示唆しています。個人的にはオブジェクト指向Fortranは結構好きでよく使っており記事も書いていますが、使用者は実感として少ないです）。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"ソースコードは書かれた時間と空間から離れれば離れるほど読みにくくなります。書いた本人が書いた直後であればコードの意図を取ることは簡単で、どんなに読みにくくてもコメントがなくても問題はありません。複数人で開発している場合は書いた人に聞くことでまだコードを理解できます。一方、書いてから10年経ってしまったコードは書いた本人にも意図がわからなくなってしまう場合があります。これを避けるためには、なるべく、書きやすく、読みやすく、メンテナンスしやすい、コードを書く必要があります。Fortranは少数での開発が多かったためかあまりこの視点に立ったコーディングスタイルが広まってきませんでした（気象庁のFortran 標準コーディングルールは有名ですが、今となっては古いと言えるでしょう。現代であればFortranをコーディングする際に気をつけていることが参考になります）。一方、プログラミング業界自体は日進月歩で進歩しているために、この視点に立った多くのノウハウが蓄積されています。一番有名なのはオブジェクト指向における「デザインパターン」でしょうか。 Juliaは2018年にバージョン1になった極めて新しい言語でして、現代のコーディングの良いところをなるべく取り込むようにデザインされています。ですので、Juliaでコードを書くとモダンな読みやすいメンテナンスしやすいコードを書くことができます。","category":"page"},{"location":"#.-古（いにしえ）のFORTRANコードから決別できる（かもしれない）","page":"Fortranから始めるJulia","title":"4. 古（いにしえ）のFORTRANコードから決別できる（かもしれない）","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"2010年代には確実に使われていた古いFORTRANコードを紹介します。そのコードはあるレビュー論文のコード(動的平均場理論の数値計算用のコード)の一部分でして、非線形関数の最小値を求めるコードです。そのコードのコメントに","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"C========+=========+=========+=========+=========+=========+=========+=$\nC PROGRAM: minimize\nC TYPE   : subroutine\nC PURPOSE: conjugent gradient search\nC I/O    : \nC VERSION: 30-Sep-95\nC COMMENT: This is a most reliable conjugent gradient routine! It has\nC          served us well for many years, and is capable to cope with\nC          a very large number of variables. Unfortunately, we don't\nC          know who wrote this routine (original name: 'va10a'), and \nC          we find it very obscure.\nC          Don't worry, it works just fine.\nCnoprint================================================================","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"とあります。1995年の時点で誰が書いたかわからないのですが、よく動く、という理由で2010年代にも使われていました（今でも使われているかもしれません）。このコードはdoループをdo,enddoで閉じるのではく、行番号とcontinue文で制御しており、ループから抜け出したりgotoで移動したりが多発するコードです。確かによく動き、ちゃんとした解を返します。私は一度このコードをFortran90に書き換えようと試みたことがありますが、私には無理でした。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Juliaの場合、このコードを使わなくてもOptimというパッケージを使えば非線形関数の最小値を求めることができます。","category":"page"},{"location":"#追記","page":"Fortranから始めるJulia","title":"追記","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"このコードについて調べてみたところ、ついに元のコードの情報が書かれている文献（R.Fletcherの\"FORTRAN SUBROUTINES FOR MINIMIZATION BY QUASI-NEWTON METHODS\", Research group report(United Kingdom Atomic Energy Authority)）を見つけました。これによると、このコードva10aは1972年の4月に書かれたそうです！","category":"page"},{"location":"#.-Fortranと文法が似ている","page":"Fortranから始めるJulia","title":"5. Fortranと文法が似ている","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"配列の添字が1始まりであるため、Fortranのコードを素朴に移植することが容易です。PythonやCは0始まりですから、それらよりも違和感は少ないと思います。 FortranとJuliaがどのくらい文法が似ているかは後述します。","category":"page"},{"location":"#動作確認に使用したJuliaのバージョン","page":"Fortranから始めるJulia","title":"動作確認に使用したJuliaのバージョン","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Julia 1.6.1","category":"page"},{"location":"#このウェブサイトの作成者","page":"Fortranから始めるJulia","title":"このウェブサイトの作成者","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"Yuki Nagai, Ph.D","category":"page"},{"location":"#有用な本","page":"Fortranから始めるJulia","title":"有用な本","text":"","category":"section"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"以下の本はJulia言語を理解する上で役に立つと思います。","category":"page"},{"location":"","page":"Fortranから始めるJulia","title":"Fortranから始めるJulia","text":"進藤 裕之, 佐藤 建太, \"1から始めるJuliaプログラミング\", コロナ社(2020) ","category":"page"}]
}
