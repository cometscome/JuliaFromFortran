# FortranのコードをJuliaへ移植してみる

## マンデルブロ集合

こちらの[記事](https://qiita.com/cure_honey/items/795bd0e048ffeadc3e63)にはさまざまなFortranのバージョンで書かれたマンデルブロ集合のコードが紹介されています。

### Fortran90
この記事の中のFortran90のコードを引用します。コードは

```fortran
PROGRAM mandel
    IMPLICIT NONE
    INTEGER, PARAMETER :: nx = 61, ny = 31, maxiter = 90
    REAL   , PARAMETER :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    INTEGER :: ix, iy, iter, mandelbrot(nx, ny)
    REAL :: x, y
    COMPLEX :: z, c
    DO iy = 1, ny
      y = y0 + (y1 - y0) * (iy - 1) / REAL(ny - 1) 
      DO ix = 1, nx
        x = x0 + (x1 - x0) * (ix - 1) / REAL(nx - 1)  
        c = CMPLX(x, y)
        z = (0.0, 0.0)
        DO iter = 0, maxiter
          z = z * z + c
          IF (ABS(z) > 2.0) EXIT
        END DO    
        mandelbrot(ix, iy) = iter
      END DO    
    END DO
!
    DO iy = 1, ny     
      PRINT '(61I1)', (mandelbrot(:, iy) + 9) / 10 
    END DO          
    STOP
END PROGRAM mandel
```
です。このコードをgfortranでコンパイルし、実行しますと、
```
0000000000000000000000000000001000000000000000000000000000000
0000000000000000000011111111111111111111100000000000000000000
0000000000000000111111111111111111111111111110000000000000000
0000000000001111111111111111111111111111111111111000000000000
0000000000111111111111111111111111111111111111111110000000000
0000000011111111111111111111111111111111111111111111100000000
0000001111111111111111111111111111111111111111111111111000000
0000011111111111111111111111111111111111111111111111111100000
0000111111111111111111111111211111111111111111111111111110000
000111111111111111111111111***2111111111111111111111111111000
0011111111111111111113312223*72671111111111111111111111111100
0011111111111111111111*************61111111111111111111111100
011111111111111111112***************1111111111111111111111110
0111111111112*4*3412****************2111111111111111111111110
011111111212************************5111111111111111111111110
**********************************311111111111111111111111111
011111111212************************5111111111111111111111110
0111111111112*4*3412****************2111111111111111111111110
011111111111111111112***************1111111111111111111111110
0011111111111111111111*************61111111111111111111111100
0011111111111111111113312223*72661111111111111111111111111100
000111111111111111111111111***2111111111111111111111111111000
0000111111111111111111111111211111111111111111111111111110000
0000011111111111111111111111111111111111111111111111111100000
0000001111111111111111111111111111111111111111111111111000000
0000000011111111111111111111111111111111111111111111100000000
0000000000111111111111111111111111111111111111111110000000000
0000000000001111111111111111111111111111111111111000000000000
0000000000000000111111111111111111111111111110000000000000000
0000000000000000000011111111111111111111100000000000000000000
0000000000000000000000000000001000000000000000000000000000000
```
という出力が得られます。この出力を再現するようなJuliaのコードを書いてみましょう。

作ったJuliaのコードは
```julia
function mandel()
    nx = 61; ny = 31; maxiter = 90
    x0 = -2.0; x1 = 2.0; y0 = -2.0; y1 = 2.0
    mandelbrot = zeros(Int64,nx, ny)
    mandelbrot .= maxiter
    for iy=1:ny
        y = y0 + (y1 - y0) * (iy - 1) / real(ny - 1) 
        for ix=1:nx
            x = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)
            c = x + im*y
            z = 0im
            for iter=0:maxiter
                z = z * z + c
                if abs(z) > 2
                    mandelbrot[ix,iy] = iter
                    break
                end
            end
            
        end
    end
    for iy=1:ny
        for ix=1:nx
            if mandelbrot[ix,iy] == maxiter
                print("*")
            else
                print((mandelbrot[ix,iy]+9) ÷ 10)
            end
        end
        println("\t")
    end
end
mandel()
```
です。

ポイントは
1. ```program mandel```を```function mandel()```に変更
2. ```;```を使い一行に複数の文を入れた
3. 配列```mandelbrot```を```mandelbrot = zeros(Int64,nx, ny)```で定義
4. Fortranでループを抜けるexitは、対応するbreakに変更
5. Fortranは```do iter = 0, maxiter```のループの途中で抜けた場合```iter```には抜けた時の値が入っているが、Juliaでは```iter```のスコープがローカルなので外では未定義になっている。そのため、```mandelbrot[ix,iy] = iter```とした
6. ```iter```のループが最大まで到達した時に、Fortranでは```mandelbrot(ix, iy)```の中身はループの最後の値```maxiter```になるが、Juliaでは前述のように```iter```はローカルスコープの変数なので値が入らない。なので、最初に```mandelbrot .= maxiter```と初期化した

などです。見比べるとはっきりとわかりますが、Fortran90のコードとJuliaのコードはよく似ています。

### Fortran90 モジュールを使用
次は、モジュールを使用したコードをJuliaコードに変化させてみます。
コードはこちらの[記事](https://qiita.com/cure_honey/items/795bd0e048ffeadc3e63)からの引用しまして、

```fortran
MODULE m_mandel
    IMPLICIT NONE
    INTEGER, PARAMETER :: maxiter = 90
  CONTAINS
    INTEGER FUNCTION mandel(c)
      COMPLEX, INTENT(IN) :: c
      COMPLEX :: z
      z = (0.0, 0.0)
      DO mandel = 0, maxiter
        z = z * z + c
        IF (ABS(z) > 2.0) EXIT
      END DO    
    END FUNCTION mandel 
  END MODULE m_mandel

  PROGRAM mandel_main
    USE m_mandel
    IMPLICIT NONE
    INTEGER, PARAMETER :: nx = 61, ny = 31
    REAL   , PARAMETER :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    INTEGER :: ix, iy, iter, mandelbrot(nx, ny)
    REAL :: x, y
    DO iy = 1, ny
      y = y0 + (y1 - y0) * (iy - 1) / REAL(ny - 1)   
      DO ix = 1, nx
        x = x0 + (x1 - x0) * (ix - 1) / REAL(nx - 1)  
        mandelbrot(ix, iy) = mandel(CMPLX(x, y)) 
      END DO    
    END DO
!
    DO iy = 1, ny
      PRINT '(61i1)', (mandelbrot(:, iy) + 9) / 10  
    END DO    
    STOP
  END PROGRAM mandel_main
```
というものです。

このコードをJuliaに移植してみますと、

```julia
module M_mandel
    const maxiter = 90
    export mandel,maxiter

    function mandel(c)
        z = 0im
        count = maxiter
        for i=0:maxiter
            z = z * z + c
            if abs(z) > 2
                count = i
                break
            end
        end
        return count
    end
end

using .M_mandel
function mandel_main()
    nx = 61;ny = 31
    x0 = -2.0;x1 = 2.0;y0 = -2.0;y1 = 2.0
    mandelbrot = zeros(Int64,nx, ny)

    for iy=1:ny
        y = y0 + (y1 - y0) * (iy - 1) / real(ny - 1)
        for ix=1:nx
            x = x0 + (x1 - x0) * (ix - 1) / real(nx - 1)
            mandelbrot[ix, iy] = mandel(x+im*y) 
        end  
    end
    
    for iy=1:ny
        for ix=1:nx
            if mandelbrot[ix,iy] == maxiter
                print("*")
            else
                print((mandelbrot[ix,iy]+9) ÷ 10)
            end
        end
        println("\t")
    end
end
mandel_main()
```

となります。

一つ目のFortran90コードで気をつけたポイントの他には、
1. ```MODULE```は```module```に。モジュールの名前はJuliaでは最初の一文字を大文字にする慣例があるのでそれにならった
2. ```USE m_mandel```は```using .M_mandel```に。関数の中ではなく、外に定義する
3. Fortranではモジュール内で宣言した変数や関数はデフォルトで```share```属性を持っており```use```ですぐに使えるが、Juliaの場合に同様にしたい場合には```export```をモジュール内で使っておく。使わない場合は```M_mandel.mandel(x+im*y)```とアクセスすることになる

ということに気をつけました。

### Fortran2003
次は、同じ[記事](https://qiita.com/cure_honey/items/795bd0e048ffeadc3e63)のFortran2003のコードをJuliaに移植してみます。Fortranのコードを引用すると

```fortran
program mandel
    implicit none
    integer, parameter :: maxiter = 90, nx = 61, ny = 31
    real   , parameter :: x0 = -2.0, x1 = 2.0, y0 = -2.0, y1 = 2.0
    character(len = 10), parameter :: text = '|+o0O.@*#-'  
    integer :: ix, iy, iter, mandelbrot(nx, ny) = 0, m(nx)  
    real, allocatable :: x(:), y(:)
    complex :: c(nx, ny), z(nx, ny) = (0.0, 0.0)
    x = [( (x1 - x0) / (nx - 1) * (ix - 1) + x0, ix = 1, nx )]
    y = [( (y1 - y0) / (ny - 1) * (iy - 1) + y0, iy = 1, ny )]
    forall (ix = 1:nx, iy = 1:ny) c(ix, iy) = cmplx(x(ix), y(iy))
    do iter = 0, maxiter
      where (abs(z) <= 2.0) 
        z = z * z + c
        mandelbrot = mandelbrot + 1
      end where  
    end do

    do iy = 1, ny
      m = (mandelbrot(:, iy) + 8) / 10  + 1
      write(*, '(61a1)') (text(m(ix):m(ix)), ix = 1, nx)  
    end do
    stop
end program mandel
```
となります。このコードをコンパイルして実行すると、

```
||||||||||||||||||||||||||||||+||||||||||||||||||||||||||||||
||||||||||||||||||||+++++++++++++++++++++||||||||||||||||||||
||||||||||||||||+++++++++++++++++++++++++++++||||||||||||||||
||||||||||||+++++++++++++++++++++++++++++++++++++||||||||||||
||||||||||+++++++++++++++++++++++++++++++++++++++++||||||||||
||||||||+++++++++++++++++++++++++++++++++++++++++++++||||||||
||||||+++++++++++++++++++++++++++++++++++++++++++++++++||||||
|||||+++++++++++++++++++++++++++++++++++++++++++++++++++|||||
||||++++++++++++++++++++++++o++++++++++++++++++++++++++++||||
|||++++++++++++++++++++++++---o+++++++++++++++++++++++++++|||
||+++++++++++++++++++00+ooo0-*o@*++++++++++++++++++++++++++||
||++++++++++++++++++++-------------@+++++++++++++++++++++++||
|+++++++++++++++++++o---------------++++++++++++++++++++++++|
|+++++++++++o-O-0O+o----------------o+++++++++++++++++++++++|
|++++++++o+o------------------------.+++++++++++++++++++++++|
----------------------------------0++++++++++++++++++++++++++
|++++++++o+o------------------------.+++++++++++++++++++++++|
|+++++++++++o-O-0O+o----------------o+++++++++++++++++++++++|
|+++++++++++++++++++o---------------++++++++++++++++++++++++|
||++++++++++++++++++++-------------@+++++++++++++++++++++++||
||+++++++++++++++++++00+ooo0-*o@@++++++++++++++++++++++++++||
|||++++++++++++++++++++++++---o+++++++++++++++++++++++++++|||
||||++++++++++++++++++++++++o++++++++++++++++++++++++++++||||
|||||+++++++++++++++++++++++++++++++++++++++++++++++++++|||||
||||||++++++++++++++++++++++++++++++++++++++++++++++++|||||||
||||||||+++++++++++++++++++++++++++++++++++++++++++++||||||||
||||||||||+++++++++++++++++++++++++++++++++++++++++||||||||||
||||||||||||++++++++++++++++++++++++++++++++++++|||||||||||||
||||||||||||||||+++++++++++++++++++++++++++++||||||||||||||||
||||||||||||||||||||+++++++++++++++++++++||||||||||||||||||||
||||||||||||||||||||||||||||||+||||||||||||||||||||||||||||||
```
となります。

対応するJuliaのコードは
```julia
function mandel()
    maxiter = 90;nx = 61; ny = 31
    x0 = -2.0; x1 = 2.0; y0 = -2.0; y1 = 2.0

    text = "|+o0O.@*#-"
    z = zeros(ComplexF64,nx,ny)
    mandelbrot = zeros(Int64,nx,ny)

    x = [ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]
    y = [ (y1 - y0) / (ny - 1) * (iy - 1) + y0  for iy = 1:ny]
    c = [ x[ix]+im*y[iy] for ix=1:nx,iy=1:ny]
    for iter=0:maxiter
        for i=1:length(z)
            if abs(z[i]) <= 2
                z[i] = z[i]*z[i]+c[i]
                mandelbrot[i] += 1
            end
        end
    end

    for iy=1:ny
        m = (mandelbrot[:, iy] .+ 8) .÷ 10  .+ 1
        [print(text[m[ix]:m[ix]]) for ix=1:nx]
        println("\t")
    end
end
mandel()
```
です。Fortranでのwhere構文（配列の各要素に条件式を当てはめてループする構文）のJulia対応が分かりませんでしたので、仕方がないので```for```ループを使いました。ただし、そのまま書いても芸がありませんので、2次元配列のzなどを1次元配列として取り出す方法を使ってみました。Juliaでは2次元配列をメモリ格納順に並べた1次元のインデックスを用いて値を操作することができます。

今回は
1.  for文のリスト内包表記```[ (x1 - x0) / (nx - 1) * (ix - 1) + x0  for ix = 1:nx]```の使用
2. Fortranの```forall```の代わりに二重forループのリスト内包表記の使用

を行いました。

### Fortran2003 オブジェクト指向
